{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dependencies \u00b6 Constructor injection designed with OOP in mind. Documentation | Source Code | Task Tracker Dependency Injection (or simply DI) is a great technique. By using it you can organize responsibilities in you codebase. Define high level policies and system behavior in one part. Delegate control to low level mechanisms in another part. Simple and powerful. With help of DI you can use different parts of your system independently and combine their behavior really easy. If you split logic and implementation into different classes, you will see how pleasant it becomes to change your system. This tiny library helps you to connect parts of your system, in particular - to inject low level implementation into high level behavior. Pros \u00b6 Provide composition instead of inheritance. Solves top-down architecture problems. Boilerplate-free object hierarchies. API entrypoints, admin panels, CLI commands are oneliners. Example \u00b6 Dependency injection without dependencies >>> from app.robot import Robot , Servo , Amplifier , Controller , Settings >>> robot = Robot ( ... servo = Servo ( amplifier = Amplifier ()), ... controller = Controller (), ... settings = Settings ( environment = \"production\" ), ... ) >>> robot . work () Dependency injection with dependencies >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = Servo ... amplifier = Amplifier ... controller = Controller ... settings = Settings ... environment = \"production\" >>> Container . robot . work () Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. Enterprise support \u00b6 If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it. License \u00b6 dependencies library is offered under the two clause BSD license. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Home"},{"location":"#dependencies","text":"Constructor injection designed with OOP in mind. Documentation | Source Code | Task Tracker Dependency Injection (or simply DI) is a great technique. By using it you can organize responsibilities in you codebase. Define high level policies and system behavior in one part. Delegate control to low level mechanisms in another part. Simple and powerful. With help of DI you can use different parts of your system independently and combine their behavior really easy. If you split logic and implementation into different classes, you will see how pleasant it becomes to change your system. This tiny library helps you to connect parts of your system, in particular - to inject low level implementation into high level behavior.","title":"Dependencies"},{"location":"#pros","text":"Provide composition instead of inheritance. Solves top-down architecture problems. Boilerplate-free object hierarchies. API entrypoints, admin panels, CLI commands are oneliners.","title":"Pros"},{"location":"#example","text":"Dependency injection without dependencies >>> from app.robot import Robot , Servo , Amplifier , Controller , Settings >>> robot = Robot ( ... servo = Servo ( amplifier = Amplifier ()), ... controller = Controller (), ... settings = Settings ( environment = \"production\" ), ... ) >>> robot . work () Dependency injection with dependencies >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = Servo ... amplifier = Amplifier ... controller = Controller ... settings = Settings ... environment = \"production\" >>> Container . robot . work ()","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#enterprise-support","text":"If you have an issue with any version of the library, you can apply for a paid enterprise support contract. This will guarantee you that no breaking changes will happen to you. No matter how old version you're using at the moment. All necessary features and bug fixes will be backported in a way that serves your needs. Please contact proofit404@gmail.com if you're interested in it.","title":"Enterprise support"},{"location":"#license","text":"dependencies library is offered under the two clause BSD license. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"License"},{"location":"attrs/","text":"Using attrs \u00b6 attrs is the Python package that will bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods). It's an excellent library. Personally, I use it heavily in all projects. Inject classes \u00b6 Here is an example of how to use it together with dependencies . >>> from attr import attrs , attrib >>> from dependencies import Injector >>> @attrs ... class Order : ... price = attrib () ... items = attrib () >>> class Container ( Injector ): ... order = Order ... price = ( 799 , 99 ) ... items = [ \"amplifier\" , \"servo\" ] >>> Container . order Order(price=(799, 99), items=['amplifier', 'servo']) As you can see, instances of a class defined with attrs are built completely the same way we build handwritten classes. But there is no need to write all this boilerplate by hand. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Attrs"},{"location":"attrs/#using-attrs","text":"attrs is the Python package that will bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods). It's an excellent library. Personally, I use it heavily in all projects.","title":"Using attrs"},{"location":"attrs/#inject-classes","text":"Here is an example of how to use it together with dependencies . >>> from attr import attrs , attrib >>> from dependencies import Injector >>> @attrs ... class Order : ... price = attrib () ... items = attrib () >>> class Container ( Injector ): ... order = Order ... price = ( 799 , 99 ) ... items = [ \"amplifier\" , \"servo\" ] >>> Container . order Order(price=(799, 99), items=['amplifier', 'servo']) As you can see, instances of a class defined with attrs are built completely the same way we build handwritten classes. But there is no need to write all this boilerplate by hand. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Inject classes"},{"location":"changelog/","text":"6.0.1 (2021-02-20) \u00b6 Bug Fixes \u00b6 custom error message for enumerations #121 ( 30cf46e ) 6.0.0 (2021-02-12) \u00b6 Features \u00b6 deprecate @operation object #457 ( 917b62f ) BREAKING CHANGES \u00b6 @operation object was removed. You could replace it with @value object returning inner function. This inner function would use it's closure to resolve injected dependencies. 5.2.0 (2020-11-21) \u00b6 Features \u00b6 support descriptor protocol #25 ( 66111b5 ) 5.1.0 (2020-11-20) \u00b6 Features \u00b6 support pypy interpreter #42 ( bb454e7 ) 5.0.0 (2020-11-12) \u00b6 Build System \u00b6 add python 3.9 support #410 ( a9526bb ) BREAKING CHANGES \u00b6 drop python 3.6 support. 4.1.0 (2020-10-23) \u00b6 Features \u00b6 deny to use empty extension scope #398 ( 18fb528 ) 4.0.1 (2020-10-02) \u00b6 Bug Fixes \u00b6 handle shadowed default arguments #240 ( 04f795f ) 4.0.0 (2020-10-01) \u00b6 Bug Fixes \u00b6 correct default argument error message #239 ( 1d7c436 ) Features \u00b6 replace let attribute with call #315 ( 1c84ea9 ) BREAKING CHANGES \u00b6 let attribute was removed. Use Injector() instead of obsolete Injector.let() . 3.0.0 (2020-08-30) \u00b6 Code Refactoring \u00b6 drop Python 2.7 and 3.4 support #348 ( 360ad90 ) BREAKING CHANGES \u00b6 Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life. 2.0.1 (2020-07-16) \u00b6 Bug Fixes \u00b6 compatibility with typing module on Python 3.6 ( 137741f ) 2.0.0 (2020-05-17) \u00b6 Features \u00b6 remove contrib package ( 5bfe041 ), closes #192 BREAKING CHANGES \u00b6 Every time a new user asks me how to use their favorite framework together with stories and dependencies I understand that there is a missing module in the contrib package. 1.0.1 (2020-03-31) \u00b6 Bug Fixes \u00b6 add wrapped attribute ( e3c7aa9 ) 1.0.0 (2020-02-11) \u00b6 Bug Fixes \u00b6 prevent generated changelog from style guide violation ( d3a472f ) 0.15 (2018-07-21) \u00b6 Support in checks in the Injector subclasses. Add operation decorator to build injectable functions. Add Package object to reduce import boilerplate in the Injector definition. Add Celery contrib to define tasks from Injector subclasses. Add Py.Test contrib to define fixtures from Injector subclasses. Add Django contrib to define views from Injector subclasses. Add Django REST Framework contrib to define API views and model view sets from Injector subclasses. A class named attributes should end with _class . Improved error messages for missing dependencies. Raise DependencyError instead of AttributeError for missed dependencies. Drop python 2.6 and 3.4 support. 0.14 (2018-04-13) \u00b6 Add this object for aliases and cross injector links. Deprecate attribute assignment and use decorator. Release under BSD license. 0.13 (2016-10-09) \u00b6 Performance improvements. 0.12 (2016-09-29) \u00b6 Allow multiple inheritance for Injector subclasses. Evaluate dependencies once. Add use decorator. Allow nested injectors. 0.11 (2016-08-22) \u00b6 Twelve times speed up. Protect from incorrect operations with attribute assignment. Deny *args and **kwargs in the injectable classes. Classes can be used as default argument values only if argument name ends with _cls . Remove six library from install requires. 0.10 (2016-06-09) \u00b6 Turn into module. 0.9 (2016-06-08) \u00b6 Dependency assignment and cancellation for Injector subclasses. 0.8 (2016-06-05) \u00b6 Correct syntax error for Python 2.6 0.7 (2016-06-04) \u00b6 Raise DependencyError for mutual recursion in constructor arguments and specified dependencies. Show injected dependencies in the dir result. Deny to instantiate Injector and its subclasses. 0.6 (2016-03-09) \u00b6 Deprecate c alias. Use real classes. Allow to use let directly on Injector . Do not instantiate dependencies named with cls at the end. 0.5 (2016-03-03) \u00b6 Avoid attribute search recursion. This occurs with inheritance chain length started at 3 and missing dependency on first level. Add c alias for Injector subclass access. Add let factory to temporarily overwrite specified dependencies. 0.4 (2016-03-03) \u00b6 Detect object.__init__ and skip it in the argument injection. 0.3 (2016-03-02) \u00b6 Deprecate injectable mechanism. Injector may inject any arguments to any classes. Injector now support multiple DI targets. All possible targets now specified in the Injector attributes. Only single base inheritance allowed for Injector subclasses. 0.2 (2016-02-13) \u00b6 Allows to override dependencies specified with Injector by inheritance from this Injector subclass. 0.1 (2016-01-31) \u00b6 Initial release. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#601-2021-02-20","text":"","title":"6.0.1 (2021-02-20)"},{"location":"changelog/#bug-fixes","text":"custom error message for enumerations #121 ( 30cf46e )","title":"Bug Fixes"},{"location":"changelog/#600-2021-02-12","text":"","title":"6.0.0 (2021-02-12)"},{"location":"changelog/#features","text":"deprecate @operation object #457 ( 917b62f )","title":"Features"},{"location":"changelog/#breaking-changes","text":"@operation object was removed. You could replace it with @value object returning inner function. This inner function would use it's closure to resolve injected dependencies.","title":"BREAKING CHANGES"},{"location":"changelog/#520-2020-11-21","text":"","title":"5.2.0 (2020-11-21)"},{"location":"changelog/#features_1","text":"support descriptor protocol #25 ( 66111b5 )","title":"Features"},{"location":"changelog/#510-2020-11-20","text":"","title":"5.1.0 (2020-11-20)"},{"location":"changelog/#features_2","text":"support pypy interpreter #42 ( bb454e7 )","title":"Features"},{"location":"changelog/#500-2020-11-12","text":"","title":"5.0.0 (2020-11-12)"},{"location":"changelog/#build-system","text":"add python 3.9 support #410 ( a9526bb )","title":"Build System"},{"location":"changelog/#breaking-changes_1","text":"drop python 3.6 support.","title":"BREAKING CHANGES"},{"location":"changelog/#410-2020-10-23","text":"","title":"4.1.0 (2020-10-23)"},{"location":"changelog/#features_3","text":"deny to use empty extension scope #398 ( 18fb528 )","title":"Features"},{"location":"changelog/#401-2020-10-02","text":"","title":"4.0.1 (2020-10-02)"},{"location":"changelog/#bug-fixes_1","text":"handle shadowed default arguments #240 ( 04f795f )","title":"Bug Fixes"},{"location":"changelog/#400-2020-10-01","text":"","title":"4.0.0 (2020-10-01)"},{"location":"changelog/#bug-fixes_2","text":"correct default argument error message #239 ( 1d7c436 )","title":"Bug Fixes"},{"location":"changelog/#features_4","text":"replace let attribute with call #315 ( 1c84ea9 )","title":"Features"},{"location":"changelog/#breaking-changes_2","text":"let attribute was removed. Use Injector() instead of obsolete Injector.let() .","title":"BREAKING CHANGES"},{"location":"changelog/#300-2020-08-30","text":"","title":"3.0.0 (2020-08-30)"},{"location":"changelog/#code-refactoring","text":"drop Python 2.7 and 3.4 support #348 ( 360ad90 )","title":"Code Refactoring"},{"location":"changelog/#breaking-changes_3","text":"Due to the our new policy of enterprise user support we will drop abandoned version of python and libraries we are integrated with as soon as they reach official end of life.","title":"BREAKING CHANGES"},{"location":"changelog/#201-2020-07-16","text":"","title":"2.0.1 (2020-07-16)"},{"location":"changelog/#bug-fixes_3","text":"compatibility with typing module on Python 3.6 ( 137741f )","title":"Bug Fixes"},{"location":"changelog/#200-2020-05-17","text":"","title":"2.0.0 (2020-05-17)"},{"location":"changelog/#features_5","text":"remove contrib package ( 5bfe041 ), closes #192","title":"Features"},{"location":"changelog/#breaking-changes_4","text":"Every time a new user asks me how to use their favorite framework together with stories and dependencies I understand that there is a missing module in the contrib package.","title":"BREAKING CHANGES"},{"location":"changelog/#101-2020-03-31","text":"","title":"1.0.1 (2020-03-31)"},{"location":"changelog/#bug-fixes_4","text":"add wrapped attribute ( e3c7aa9 )","title":"Bug Fixes"},{"location":"changelog/#100-2020-02-11","text":"","title":"1.0.0 (2020-02-11)"},{"location":"changelog/#bug-fixes_5","text":"prevent generated changelog from style guide violation ( d3a472f )","title":"Bug Fixes"},{"location":"changelog/#015-2018-07-21","text":"Support in checks in the Injector subclasses. Add operation decorator to build injectable functions. Add Package object to reduce import boilerplate in the Injector definition. Add Celery contrib to define tasks from Injector subclasses. Add Py.Test contrib to define fixtures from Injector subclasses. Add Django contrib to define views from Injector subclasses. Add Django REST Framework contrib to define API views and model view sets from Injector subclasses. A class named attributes should end with _class . Improved error messages for missing dependencies. Raise DependencyError instead of AttributeError for missed dependencies. Drop python 2.6 and 3.4 support.","title":"0.15 (2018-07-21)"},{"location":"changelog/#014-2018-04-13","text":"Add this object for aliases and cross injector links. Deprecate attribute assignment and use decorator. Release under BSD license.","title":"0.14 (2018-04-13)"},{"location":"changelog/#013-2016-10-09","text":"Performance improvements.","title":"0.13 (2016-10-09)"},{"location":"changelog/#012-2016-09-29","text":"Allow multiple inheritance for Injector subclasses. Evaluate dependencies once. Add use decorator. Allow nested injectors.","title":"0.12 (2016-09-29)"},{"location":"changelog/#011-2016-08-22","text":"Twelve times speed up. Protect from incorrect operations with attribute assignment. Deny *args and **kwargs in the injectable classes. Classes can be used as default argument values only if argument name ends with _cls . Remove six library from install requires.","title":"0.11 (2016-08-22)"},{"location":"changelog/#010-2016-06-09","text":"Turn into module.","title":"0.10 (2016-06-09)"},{"location":"changelog/#09-2016-06-08","text":"Dependency assignment and cancellation for Injector subclasses.","title":"0.9 (2016-06-08)"},{"location":"changelog/#08-2016-06-05","text":"Correct syntax error for Python 2.6","title":"0.8 (2016-06-05)"},{"location":"changelog/#07-2016-06-04","text":"Raise DependencyError for mutual recursion in constructor arguments and specified dependencies. Show injected dependencies in the dir result. Deny to instantiate Injector and its subclasses.","title":"0.7 (2016-06-04)"},{"location":"changelog/#06-2016-03-09","text":"Deprecate c alias. Use real classes. Allow to use let directly on Injector . Do not instantiate dependencies named with cls at the end.","title":"0.6 (2016-03-09)"},{"location":"changelog/#05-2016-03-03","text":"Avoid attribute search recursion. This occurs with inheritance chain length started at 3 and missing dependency on first level. Add c alias for Injector subclass access. Add let factory to temporarily overwrite specified dependencies.","title":"0.5 (2016-03-03)"},{"location":"changelog/#04-2016-03-03","text":"Detect object.__init__ and skip it in the argument injection.","title":"0.4 (2016-03-03)"},{"location":"changelog/#03-2016-03-02","text":"Deprecate injectable mechanism. Injector may inject any arguments to any classes. Injector now support multiple DI targets. All possible targets now specified in the Injector attributes. Only single base inheritance allowed for Injector subclasses.","title":"0.3 (2016-03-02)"},{"location":"changelog/#02-2016-02-13","text":"Allows to override dependencies specified with Injector by inheritance from this Injector subclass.","title":"0.2 (2016-02-13)"},{"location":"changelog/#01-2016-01-31","text":"Initial release. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"0.1 (2016-01-31)"},{"location":"descriptors/","text":"Descriptors \u00b6 Descriptors is a powerful feature of the python language. It allows an object to know in attribute of what other object it is stored. Python will know an object is a descriptor if it implements descriptor protocol. In other words, if it defines __get__ , __set__ , and __delete__ methods. >>> class Descriptor : ... def __get__ ( self , instance , klass ): ... print ( \"=>\" , instance ) ... print ( \"=>\" , klass ) ... return 1 >>> class Holder : ... attribute = Descriptor () >>> Holder () . attribute # doctest: +ELLIPSIS => <__main__.Holder object at 0x...> => <class '__main__.Holder'> 1 >>> Holder . attribute => None => <class '__main__.Holder'> 1 Probably, you don't write code like that frequently. But a lot of your code uses descriptors already. For example, @property decorator and fields of Django models are implemented as descriptors. >>> @property ... def attribute ( self ): ... return 1 >>> hasattr ( attribute , '__get__' ) True >>> hasattr ( attribute , '__set__' ) True Inconsistency with dependencies \u00b6 As you already noticed descriptors could be assigned only at class definition time. Descriptor protocol will not be used in case you assign descriptor object to the object attribute. >>> class Wrong : ... ... def __init__ ( self , attribute ): ... ... self . attribute = attribute >>> Wrong ( Descriptor ()) . attribute # doctest: +ELLIPSIS <__main__.Descriptor object at 0x...> The code above does not execute __get__ method. It returns descriptor object as is. Most of the times dependencies library used to build instances of objects. That's why specifying descriptor as a dependency of some object would be a suspicious operation to do. You will not have access to the Injector class it self. You will not have access to the object descriptor was passed to. That's why descriptor found in the injection scope will be treated as an error. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... wrong = Wrong ... attribute = Descriptor () Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Attribute 'attribute' contains descriptor. <BLANKLINE> Descriptors usage will be confusing inside Injector subclasses. <BLANKLINE> Use @value decorator instead, if you really need inject descriptor instance somewhere. >>> class Container ( Injector ): ... ... wrong = Wrong ... ... @property ... def attribute ( self ): ... return 1 Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Attribute 'attribute' contains descriptor. <BLANKLINE> Descriptors usage will be confusing inside Injector subclasses. <BLANKLINE> Use @value decorator instead, if you really need inject descriptor instance somewhere. Inject descriptors anyway \u00b6 As we explain earlier, using descriptors in the injection scope is a user error is most cases. You don't need a workaround until you're doing something really strange like defining classes during dependency injection process or accessing Injector attributes during class definition process. If you decided to bypass this restriction, you can use @value to hide the nature of an object. >>> from dependencies import value >>> class Container ( Injector ): ... ... @value ... def attribute (): ... return Descriptor () >>> class Strange : ... ... attribute = Container . attribute >>> Strange () . attribute # doctest: +ELLIPSIS => <__main__.Strange object at 0x...> => <class '__main__.Strange'> 1 >>> Strange . attribute => None => <class '__main__.Strange'> 1 \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Descriptors"},{"location":"descriptors/#descriptors","text":"Descriptors is a powerful feature of the python language. It allows an object to know in attribute of what other object it is stored. Python will know an object is a descriptor if it implements descriptor protocol. In other words, if it defines __get__ , __set__ , and __delete__ methods. >>> class Descriptor : ... def __get__ ( self , instance , klass ): ... print ( \"=>\" , instance ) ... print ( \"=>\" , klass ) ... return 1 >>> class Holder : ... attribute = Descriptor () >>> Holder () . attribute # doctest: +ELLIPSIS => <__main__.Holder object at 0x...> => <class '__main__.Holder'> 1 >>> Holder . attribute => None => <class '__main__.Holder'> 1 Probably, you don't write code like that frequently. But a lot of your code uses descriptors already. For example, @property decorator and fields of Django models are implemented as descriptors. >>> @property ... def attribute ( self ): ... return 1 >>> hasattr ( attribute , '__get__' ) True >>> hasattr ( attribute , '__set__' ) True","title":"Descriptors"},{"location":"descriptors/#inconsistency-with-dependencies","text":"As you already noticed descriptors could be assigned only at class definition time. Descriptor protocol will not be used in case you assign descriptor object to the object attribute. >>> class Wrong : ... ... def __init__ ( self , attribute ): ... ... self . attribute = attribute >>> Wrong ( Descriptor ()) . attribute # doctest: +ELLIPSIS <__main__.Descriptor object at 0x...> The code above does not execute __get__ method. It returns descriptor object as is. Most of the times dependencies library used to build instances of objects. That's why specifying descriptor as a dependency of some object would be a suspicious operation to do. You will not have access to the Injector class it self. You will not have access to the object descriptor was passed to. That's why descriptor found in the injection scope will be treated as an error. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... wrong = Wrong ... attribute = Descriptor () Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Attribute 'attribute' contains descriptor. <BLANKLINE> Descriptors usage will be confusing inside Injector subclasses. <BLANKLINE> Use @value decorator instead, if you really need inject descriptor instance somewhere. >>> class Container ( Injector ): ... ... wrong = Wrong ... ... @property ... def attribute ( self ): ... return 1 Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Attribute 'attribute' contains descriptor. <BLANKLINE> Descriptors usage will be confusing inside Injector subclasses. <BLANKLINE> Use @value decorator instead, if you really need inject descriptor instance somewhere.","title":"Inconsistency with dependencies"},{"location":"descriptors/#inject-descriptors-anyway","text":"As we explain earlier, using descriptors in the injection scope is a user error is most cases. You don't need a workaround until you're doing something really strange like defining classes during dependency injection process or accessing Injector attributes during class definition process. If you decided to bypass this restriction, you can use @value to hide the nature of an object. >>> from dependencies import value >>> class Container ( Injector ): ... ... @value ... def attribute (): ... return Descriptor () >>> class Strange : ... ... attribute = Container . attribute >>> Strange () . attribute # doctest: +ELLIPSIS => <__main__.Strange object at 0x...> => <class '__main__.Strange'> 1 >>> Strange . attribute => None => <class '__main__.Strange'> 1 \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Inject descriptors anyway"},{"location":"enum/","text":"Enums \u00b6 Since Enum definition keep enumeration itself a class we need to instantiate it somehow. Even taking into consideration that enumeration classes are used as constants most of the times, we can't make an exclusion in the rule that classes should be instantiated. Members of enumeration are instancies of the enumeration class itself. That's why we allow to use Enum members only in the dependency injection scope. >>> from enum import Enum , auto , unique >>> from dependencies import Injector >>> @unique ... class Status ( Enum ): ... new = auto () ... accepted = auto () ... processed = auto () ... rejected = auto () ... done = auto () >>> class Order : ... def __init__ ( self , status ): ... self . status = status ... ... def __repr__ ( self ): ... return f \"Order( { self . status !r} )\" >>> class Container ( Injector ): ... order = Order ... status = Status . new >>> Container . order Order(<Status.new: 1>) In the mean time, we are strongly forbid usage Enum class itself inside injection scope. Injector will raise an error if you try to define an attribute with enumeration class in it. >>> class Container ( Injector ): ... order = Order ... status = Status Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Attribute 'status' contains Enum. <BLANKLINE> Do not inject enumeration classes. <BLANKLINE> It will be unable to instantiate this class. <BLANKLINE> Inject its members instead. Using enumeration classes in class-named attributes are still allowed. >>> class Container ( Injector ): ... order = Order ... status_class = Status As you can see, no exception was raised above. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Enums"},{"location":"enum/#enums","text":"Since Enum definition keep enumeration itself a class we need to instantiate it somehow. Even taking into consideration that enumeration classes are used as constants most of the times, we can't make an exclusion in the rule that classes should be instantiated. Members of enumeration are instancies of the enumeration class itself. That's why we allow to use Enum members only in the dependency injection scope. >>> from enum import Enum , auto , unique >>> from dependencies import Injector >>> @unique ... class Status ( Enum ): ... new = auto () ... accepted = auto () ... processed = auto () ... rejected = auto () ... done = auto () >>> class Order : ... def __init__ ( self , status ): ... self . status = status ... ... def __repr__ ( self ): ... return f \"Order( { self . status !r} )\" >>> class Container ( Injector ): ... order = Order ... status = Status . new >>> Container . order Order(<Status.new: 1>) In the mean time, we are strongly forbid usage Enum class itself inside injection scope. Injector will raise an error if you try to define an attribute with enumeration class in it. >>> class Container ( Injector ): ... order = Order ... status = Status Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Attribute 'status' contains Enum. <BLANKLINE> Do not inject enumeration classes. <BLANKLINE> It will be unable to instantiate this class. <BLANKLINE> Inject its members instead. Using enumeration classes in class-named attributes are still allowed. >>> class Container ( Injector ): ... order = Order ... status_class = Status As you can see, no exception was raised above. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Enums"},{"location":"faq/","text":"FAQ \u00b6 Why do not use type annotations? \u00b6 It is possible to look for types of __init__ arguments instead of names. Obviously, code written in this style will look something like this: >>> from app.types import TypedInjector >>> from app.purchase import ( ... AbstractPaymentService , ... PaypalService , ... AbstractNotificationService , ... SMSService , ... ) >>> class PurchaseService : ... def __init__ ( ... self , ... payments : AbstractPaymentService , ... notifications : AbstractNotificationService , ... ): ... self . payments = payments ... self . notifications = notifications >>> container = TypedInjector () >>> container . register ( SMSService ) >>> container . register ( PaypalService ) >>> container . build ( PurchaseService ) # doctest: +ELLIPSIS <__main__.PurchaseService object at 0x...> In our opinion, this makes code less declarative. It's hard to tell how dependencies will be resolved. At the same time, looking on container definition and a signature of the __init__ method can you easily say what arguments will be passed to the constructor? You can't. You will need to inspect all superclasses of each dependency registered in the container. With our Injector approach, you don't have this problem. You will find arguments right in the Injector subclass in one place. It's a global mutable variable. Container definition can be split into different files. This will make it harder to read. It's similar to the service locator. Many architect people consider it an anti-pattern. It hard to define multiple dependencies of the same type. For example, your service needs two databases to work with. You need to define two different classes for types signatures and then define two different database classes. The same is necessary for these classes arguments. Both of them needs a port to run. How would you name it? PrimaryDatabasePort and SecondaryDatabasePort instead of int ? This leads to unnecessary boilerplate. Mixins considered harmful \u00b6 dependencies are compared with mixins often, since both solutions are ways to maximize code reuse. We already discussed this in the why chapter. But let's return to it again: Note Inheritance always breaks encapsulation. Mixin class depends on attributes set in other classes. Consider this code snippet: >>> class RetrieveModelMixin : ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data ) Where were get_object and get_serializer defined? We have no idea. We believe the code below is way better in the sense of understandability: >>> class RetrieveModel : ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def __init__ ( self , get_object , get_serializer ): ... self . get_object = get_object ... self . get_serializer = get_serializer ... ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data ) What to inject, and what not to \u00b6 It can be hard to draw the border between what should be injectable and what shouldn't be. Let's consider this typical example. >>> import requests >>> import dependencies >>> class UserGetter : ... ... def __init__ ( self , http ): ... self . http = http ... ... def __call__ ( self , user_id ): ... return self . http . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) . json () >>> class Users ( dependencies . Injector ): ... ... get = UserGetter ... http = requests >>> Users . get ( 1 ) {'id': 1, 'name': 'John', 'surname': 'Doe'} Should I write code like this? Will I ever decide to use something other than the excellent requests library? In our opinion these are not the correct questions to ask. By injecting a certain library you add a hard dependency on its interfaces to the whole system. Migration to other libraries in the future can be painful. Also, this adds another hard dependency to the whole system. Your code depends on the structure of third-party API response. This makes the situation even worse. Migration to other third-party services will be painful, as well. We believe that HTTP protocol itself is an implementation detail! We prefer to use dependency injection only on boundaries we control: >>> import dataclasses >>> import dependencies >>> import requests >>> class HomePage : ... ... def __init__ ( self , get_user ): ... self . get_user = get_user ... ... def show ( self , user_id ): ... user = self . get_user ( user_id = user_id ) >>> @dataclasses . dataclass ... class UserStruct : ... ... id : int ... name : str ... surname : str >>> def get_user ( user_id ): ... ... response = requests . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) ... return UserStruct ( ** response . json ()) >>> class Site ( dependencies . Injector ): ... ... home_page = HomePage ... get_user = get_user >>> Site . home_page . show ( 1 ) \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#why-do-not-use-type-annotations","text":"It is possible to look for types of __init__ arguments instead of names. Obviously, code written in this style will look something like this: >>> from app.types import TypedInjector >>> from app.purchase import ( ... AbstractPaymentService , ... PaypalService , ... AbstractNotificationService , ... SMSService , ... ) >>> class PurchaseService : ... def __init__ ( ... self , ... payments : AbstractPaymentService , ... notifications : AbstractNotificationService , ... ): ... self . payments = payments ... self . notifications = notifications >>> container = TypedInjector () >>> container . register ( SMSService ) >>> container . register ( PaypalService ) >>> container . build ( PurchaseService ) # doctest: +ELLIPSIS <__main__.PurchaseService object at 0x...> In our opinion, this makes code less declarative. It's hard to tell how dependencies will be resolved. At the same time, looking on container definition and a signature of the __init__ method can you easily say what arguments will be passed to the constructor? You can't. You will need to inspect all superclasses of each dependency registered in the container. With our Injector approach, you don't have this problem. You will find arguments right in the Injector subclass in one place. It's a global mutable variable. Container definition can be split into different files. This will make it harder to read. It's similar to the service locator. Many architect people consider it an anti-pattern. It hard to define multiple dependencies of the same type. For example, your service needs two databases to work with. You need to define two different classes for types signatures and then define two different database classes. The same is necessary for these classes arguments. Both of them needs a port to run. How would you name it? PrimaryDatabasePort and SecondaryDatabasePort instead of int ? This leads to unnecessary boilerplate.","title":"Why do not use type annotations?"},{"location":"faq/#mixins-considered-harmful","text":"dependencies are compared with mixins often, since both solutions are ways to maximize code reuse. We already discussed this in the why chapter. But let's return to it again: Note Inheritance always breaks encapsulation. Mixin class depends on attributes set in other classes. Consider this code snippet: >>> class RetrieveModelMixin : ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data ) Where were get_object and get_serializer defined? We have no idea. We believe the code below is way better in the sense of understandability: >>> class RetrieveModel : ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def __init__ ( self , get_object , get_serializer ): ... self . get_object = get_object ... self . get_serializer = get_serializer ... ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data )","title":"Mixins considered harmful"},{"location":"faq/#what-to-inject-and-what-not-to","text":"It can be hard to draw the border between what should be injectable and what shouldn't be. Let's consider this typical example. >>> import requests >>> import dependencies >>> class UserGetter : ... ... def __init__ ( self , http ): ... self . http = http ... ... def __call__ ( self , user_id ): ... return self . http . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) . json () >>> class Users ( dependencies . Injector ): ... ... get = UserGetter ... http = requests >>> Users . get ( 1 ) {'id': 1, 'name': 'John', 'surname': 'Doe'} Should I write code like this? Will I ever decide to use something other than the excellent requests library? In our opinion these are not the correct questions to ask. By injecting a certain library you add a hard dependency on its interfaces to the whole system. Migration to other libraries in the future can be painful. Also, this adds another hard dependency to the whole system. Your code depends on the structure of third-party API response. This makes the situation even worse. Migration to other third-party services will be painful, as well. We believe that HTTP protocol itself is an implementation detail! We prefer to use dependency injection only on boundaries we control: >>> import dataclasses >>> import dependencies >>> import requests >>> class HomePage : ... ... def __init__ ( self , get_user ): ... self . get_user = get_user ... ... def show ( self , user_id ): ... user = self . get_user ( user_id = user_id ) >>> @dataclasses . dataclass ... class UserStruct : ... ... id : int ... name : str ... surname : str >>> def get_user ( user_id ): ... ... response = requests . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) ... return UserStruct ( ** response . json ()) >>> class Site ( dependencies . Injector ): ... ... home_page = HomePage ... get_user = get_user >>> Site . home_page . show ( 1 ) \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"What to inject, and what not to"},{"location":"installation/","text":"Installation \u00b6 The dependencies library is available on PyPI. To install it run: pip install -U dependencies We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The dependencies library is available on PyPI. To install it run: pip install -U dependencies We use semantic release to publish packages as soon as pull requests land to the master branch. It's not necessary to use develompment version of the library. We officially support three last minor releases of CPython interpreter and last minor release of PyPy interpreter. We highly recommend the latest patch release of each Python series. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Installation"},{"location":"package/","text":"Package object \u00b6 Package object is a way to define injector scope with dependencies defined in other places (like modules and packages). You can point package object to the module, a variable defined in the module, a function defined in the module, a class defined in the module, any attribute of the class which was defined in this module. >>> from dependencies import Injector , Package Attributes \u00b6 A usual use case for the Package object is to replace havy import statements with attribute access. If you have complex project structure, you will see a lot of code like this in your injectors. >>> from app.repositories import create_user >>> # A lot of import statements here... >>> class Container ( Injector ): ... persist_user = create_user ... # A lot of assignment statements here... To save some typing I tend to write this code like this >>> class Container ( Injector ): ... from app.repositories import create_user as persist_user ... # A lot of import statements here... Package can help to deal with this inconsistency >>> app = Package ( \"app\" ) >>> class Container ( Injector ): ... persist_user = app . repositories . create_user ... # A lot of assignment statements here... If a lot of dependencies defined in the repositories module, you can set Package source to the repositories module itself. >>> repositories = Package ( \"app.repositories\" ) >>> class Container ( Injector ): ... persist_user = repositories . create_user ... # A lot of assignment statements here... Classes \u00b6 If an attribute of the Package object point to the attribute of the class defined in some module, this class will be instantiated before attribute access is actually happen. You can inject bound methods with exactly one line. # app/calc.py >>> class Calc : ... ... def __init__ ( self , a , b ): ... self . a = a ... self . b = b ... ... def do ( self ): ... return self . a + self . b # app/base.py >>> calc = Package ( \"app.calc\" ) >>> class Container ( Injector ): ... foo = calc . Calc . do ... a = 1 ... b = 2 >>> assert Container . foo () == 3 The injector definition above is equivalent to the longuer version: >>> from dependencies import this >>> from app.calc import Calc >>> class Container ( Injector ): ... foo = this . tmp . do ... tmp = Calc ... a = 1 ... b = 2 >>> assert Container . foo () == 3 \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Package"},{"location":"package/#package-object","text":"Package object is a way to define injector scope with dependencies defined in other places (like modules and packages). You can point package object to the module, a variable defined in the module, a function defined in the module, a class defined in the module, any attribute of the class which was defined in this module. >>> from dependencies import Injector , Package","title":"Package object"},{"location":"package/#attributes","text":"A usual use case for the Package object is to replace havy import statements with attribute access. If you have complex project structure, you will see a lot of code like this in your injectors. >>> from app.repositories import create_user >>> # A lot of import statements here... >>> class Container ( Injector ): ... persist_user = create_user ... # A lot of assignment statements here... To save some typing I tend to write this code like this >>> class Container ( Injector ): ... from app.repositories import create_user as persist_user ... # A lot of import statements here... Package can help to deal with this inconsistency >>> app = Package ( \"app\" ) >>> class Container ( Injector ): ... persist_user = app . repositories . create_user ... # A lot of assignment statements here... If a lot of dependencies defined in the repositories module, you can set Package source to the repositories module itself. >>> repositories = Package ( \"app.repositories\" ) >>> class Container ( Injector ): ... persist_user = repositories . create_user ... # A lot of assignment statements here...","title":"Attributes"},{"location":"package/#classes","text":"If an attribute of the Package object point to the attribute of the class defined in some module, this class will be instantiated before attribute access is actually happen. You can inject bound methods with exactly one line. # app/calc.py >>> class Calc : ... ... def __init__ ( self , a , b ): ... self . a = a ... self . b = b ... ... def do ( self ): ... return self . a + self . b # app/base.py >>> calc = Package ( \"app.calc\" ) >>> class Container ( Injector ): ... foo = calc . Calc . do ... a = 1 ... b = 2 >>> assert Container . foo () == 3 The injector definition above is equivalent to the longuer version: >>> from dependencies import this >>> from app.calc import Calc >>> class Container ( Injector ): ... foo = this . tmp . do ... tmp = Calc ... a = 1 ... b = 2 >>> assert Container . foo () == 3 \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Classes"},{"location":"this/","text":"this object \u00b6 this is a declarative way to access attributes and items of other dependencies defined in the Injector subclasses. The Link is basically a pointer or an alias to another dependency in the same Injector , in nested Injector or in parent Injector . >>> from dependencies import Injector , this Simple links \u00b6 For example, you can create simple aliases. >>> class Container ( Injector ): ... foo = 1 ... bar = this . foo >>> Container . bar 1 You can use item access on dependencies defined in Injector subclass. >>> class Container ( Injector ): ... foo = { 'a' : 1 } ... bar = this . foo [ 'a' ] >>> Container . bar 1 Tuple, list, set and everything that supports iterable protocol are also supported. You can use this links as usual in the constructor arguments. >>> class Foo : ... def __init__ ( self , bar ): ... self . bar = bar >>> class Container ( Injector ): ... foo = Foo ... bar = this . baz ... baz = 1 >>> Container . foo . bar 1 You may notice that it is possible to define this object before the dependency it point to. You can point a link to the instance method. The actual instance will be built before resolving method access. This is a useful technique to hide whole class with its own state behind a single callable interface. >>> class Foo : ... def method ( self , arg ): ... print ( self ) ... print ( arg ) >>> class Container ( Injector ): ... foo = Foo ... bar = this . foo . method >>> Container . bar ( 1 ) # doctest: +ELLIPSIS <__main__.Foo object at 0x...> 1 You can see that method has access to the Foo instance. It can call other methods of Foo . You can define dependencies of the Foo class in it constructor as usual. Nested and parent injector access \u00b6 Links created with this objects can access attributes defined in the nested injector. >>> class Container ( Injector ): ... foo = this . Bar . baz . __add__ ... class Bar ( Injector ): ... baz = 1 >>> Container . foo ( 2 ) 3 Nested Injector subclasses can access attributes of the parent Injector . Use left shift operator to specify the number of levels to go upper scope. >>> class Container ( Injector ): ... foo = 1 ... class Bar ( Injector ): ... baz = ( this << 1 ) . foo . __add__ >>> Container . Bar . baz ( 2 ) 3 Full example \u00b6 Let's define an application with all settings stored in the dictionary. In production, you can substitute this dictionary with Consul or ZooKeeper client and the rest of the application will be left untouched. >>> class Database : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Cache : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Application : ... def __init__ ( self , db , cache ): ... self . db = db ... self . cache = cache >>> class Container ( Injector ): ... app = Application ... db = this . DB . database ... cache = this . InMemory . cache ... ... class DB ( Injector ): ... database = Database ... host = ( this << 1 ) . settings [ 'database' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'database' ][ 'port' ] ... ... class InMemory ( Injector ): ... cache = Cache ... host = ( this << 1 ) . settings [ 'cache' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'cache' ][ 'port' ] ... ... settings = { ... 'database' : { ... 'host' : 'localhost' , ... 'port' : 5432 , ... }, ... 'cache' : { ... 'host' : 'localhost' , ... 'port' : 6782 , ... }, ... } >>> Container . app # doctest: +ELLIPSIS <__main__.Application object at 0x...> >>> Container . app . db # doctest: +ELLIPSIS <__main__.Database object at 0x...> >>> Container . app . db . port 5432 >>> Container . app . cache # doctest: +ELLIPSIS <__main__.Cache object at 0x...> >>> Container . app . cache . port 6782 Environment variables \u00b6 It is possible to access environment variables during dependency injection process. If a class has a dependency in it's constructor, you can pass a value from environment variable to the constructor using this object. >>> import os >>> class App : ... ... def __init__ ( self , config ): ... ... self . config = config ... ... def __repr__ ( self ): ... ... return f 'App( { self . config !r} )' >>> class Config : ... ... def __init__ ( self , frontend_url , backend_url ): ... ... self . frontend_url = frontend_url ... self . backend_url = backend_url ... ... def __repr__ ( self ): ... ... return f 'Config( { self . frontend_url !r} , { self . backend_url !r} )' >>> class Container ( Injector ): ... ... app = App ... config = Config ... frontend_url = this . environ [ 'FRONTEND_URL' ] ... backend_url = this . environ [ 'BACKEND_URL' ] ... environ = os . environ >>> Container . app App(Config('https://example.com/frontend', 'https://example.com/backend')) \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"This"},{"location":"this/#this-object","text":"this is a declarative way to access attributes and items of other dependencies defined in the Injector subclasses. The Link is basically a pointer or an alias to another dependency in the same Injector , in nested Injector or in parent Injector . >>> from dependencies import Injector , this","title":"this object"},{"location":"this/#simple-links","text":"For example, you can create simple aliases. >>> class Container ( Injector ): ... foo = 1 ... bar = this . foo >>> Container . bar 1 You can use item access on dependencies defined in Injector subclass. >>> class Container ( Injector ): ... foo = { 'a' : 1 } ... bar = this . foo [ 'a' ] >>> Container . bar 1 Tuple, list, set and everything that supports iterable protocol are also supported. You can use this links as usual in the constructor arguments. >>> class Foo : ... def __init__ ( self , bar ): ... self . bar = bar >>> class Container ( Injector ): ... foo = Foo ... bar = this . baz ... baz = 1 >>> Container . foo . bar 1 You may notice that it is possible to define this object before the dependency it point to. You can point a link to the instance method. The actual instance will be built before resolving method access. This is a useful technique to hide whole class with its own state behind a single callable interface. >>> class Foo : ... def method ( self , arg ): ... print ( self ) ... print ( arg ) >>> class Container ( Injector ): ... foo = Foo ... bar = this . foo . method >>> Container . bar ( 1 ) # doctest: +ELLIPSIS <__main__.Foo object at 0x...> 1 You can see that method has access to the Foo instance. It can call other methods of Foo . You can define dependencies of the Foo class in it constructor as usual.","title":"Simple links"},{"location":"this/#nested-and-parent-injector-access","text":"Links created with this objects can access attributes defined in the nested injector. >>> class Container ( Injector ): ... foo = this . Bar . baz . __add__ ... class Bar ( Injector ): ... baz = 1 >>> Container . foo ( 2 ) 3 Nested Injector subclasses can access attributes of the parent Injector . Use left shift operator to specify the number of levels to go upper scope. >>> class Container ( Injector ): ... foo = 1 ... class Bar ( Injector ): ... baz = ( this << 1 ) . foo . __add__ >>> Container . Bar . baz ( 2 ) 3","title":"Nested and parent injector access"},{"location":"this/#full-example","text":"Let's define an application with all settings stored in the dictionary. In production, you can substitute this dictionary with Consul or ZooKeeper client and the rest of the application will be left untouched. >>> class Database : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Cache : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Application : ... def __init__ ( self , db , cache ): ... self . db = db ... self . cache = cache >>> class Container ( Injector ): ... app = Application ... db = this . DB . database ... cache = this . InMemory . cache ... ... class DB ( Injector ): ... database = Database ... host = ( this << 1 ) . settings [ 'database' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'database' ][ 'port' ] ... ... class InMemory ( Injector ): ... cache = Cache ... host = ( this << 1 ) . settings [ 'cache' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'cache' ][ 'port' ] ... ... settings = { ... 'database' : { ... 'host' : 'localhost' , ... 'port' : 5432 , ... }, ... 'cache' : { ... 'host' : 'localhost' , ... 'port' : 6782 , ... }, ... } >>> Container . app # doctest: +ELLIPSIS <__main__.Application object at 0x...> >>> Container . app . db # doctest: +ELLIPSIS <__main__.Database object at 0x...> >>> Container . app . db . port 5432 >>> Container . app . cache # doctest: +ELLIPSIS <__main__.Cache object at 0x...> >>> Container . app . cache . port 6782","title":"Full example"},{"location":"this/#environment-variables","text":"It is possible to access environment variables during dependency injection process. If a class has a dependency in it's constructor, you can pass a value from environment variable to the constructor using this object. >>> import os >>> class App : ... ... def __init__ ( self , config ): ... ... self . config = config ... ... def __repr__ ( self ): ... ... return f 'App( { self . config !r} )' >>> class Config : ... ... def __init__ ( self , frontend_url , backend_url ): ... ... self . frontend_url = frontend_url ... self . backend_url = backend_url ... ... def __repr__ ( self ): ... ... return f 'Config( { self . frontend_url !r} , { self . backend_url !r} )' >>> class Container ( Injector ): ... ... app = App ... config = Config ... frontend_url = this . environ [ 'FRONTEND_URL' ] ... backend_url = this . environ [ 'BACKEND_URL' ] ... environ = os . environ >>> Container . app App(Config('https://example.com/frontend', 'https://example.com/backend')) \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Environment variables"},{"location":"usage/","text":"Usage \u00b6 Preparations \u00b6 Before we start to inject dependencies, let's define code which needs these dependencies. Also, let's add some behavior to your robot. >>> class Robot : ... def __init__ ( self , servo , controller , settings ): ... self . servo = servo ... self . controller = controller ... self . settings = settings ... ... def run ( self ): ... while True : ... events = self . accept_events () ... if not events : ... break ... self . process ( events ) ... ... def accept_events ( self ): ... # We can inject methods. ... return self . controller () ... ... def process ( self , events ): ... # We can inject dictionaries. ... max_point = self . settings [ \"max_point\" ] ... for event in events : ... if event . x > max_point : ... # We can inject objects. ... self . servo . reverse ( \"x\" ) ... if event . y > max_point : ... self . servo . reverse ( \"y\" ) We use constructor-based dependency injection here: we define necessary arguments and store them explicitly, for the sake of readability. This will help us to understand the execution path of your system. Attributes sourced from nowhere in your code aren't fun. Believe me. Now, it's time to make this work in the real world. >>> class MechanicalMotor : ... def reverse ( self , coordinate ): ... # Hardware work goes here. ... pass >>> def read_sensor (): ... # Another hardware work goes here. ... return [] >>> production = { 'max_point' : 0.01 } We are close to scream \"It's alive!\" and, if we're lucky enough, run out of the building. >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = MechanicalMotor ... controller = read_sensor ... settings = production >>> robot = Container . robot # Robots' constructor called here. >>> robot . run () Congratulations! We've built our robot with dependency injection. Injection rules \u00b6 Container above is a dependency scope, and dependencies are defined as its attributes. When you access one of those attributes, the following happens: If attribute value is a class , it will be instantiated. To make that possible, the library will inspect its constructor's argument list and search current dependency scope for dependencies with the same name. If attribute value is a class but attribute name ends with _class - then it will be returned as is. (For example, Container.foo_class will return the class stored in it, not its instance). Anything else is returned as is. If, during dependency search, we encounter another class - it will be instantiated along these rules, as well. The process is recursive. Here is a demonstration of rules above. >>> class Foo : ... def __init__ ( self , one , two ): ... self . one = one ... self . two = two >>> class Bar : ... pass >>> class Baz : ... def __init__ ( self , x ): ... self . x = x >>> from dependencies import Injector >>> class Scope ( Injector ): ... foo = Foo ... one = Bar ... two = Baz ... x = 1 >>> Scope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> >>> Scope . foo . one # doctest: +ELLIPSIS <__main__.Bar object at 0x...> >>> Scope . foo . two # doctest: +ELLIPSIS <__main__.Baz object at 0x...> >>> Scope . foo . two . x 1 Let's roll down what is happening here: Foo class requires an argument named two ; In dependency scope, that argument resolves to Baz class; Which is a class - oh, we need to instantiate it as well; But its constructor requires an argument named x ; Which resolves to 1 in the dependency scope, so we do not need to go any further. Having found that out, we effectively construct, execute, and return Foo(two=Baz(x=1)) . Calculation rules \u00b6 Each dependency evaluates exactly once during injection process. If during dependency injection different classes have constructor argument with the same name, the corresponding dependency will be instantiated once and these two constructors will receive the same object. But this object only lives during one injection process; another attribute access means a new object. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar , baz ): ... self . bar = bar ... self . baz = baz ... ... def check ( self ): ... return self . bar . x is self . baz . x ... ... class Bar : ... ... def __init__ ( self , x ): ... self . x = x ... ... class Baz : ... ... def __init__ ( self , x ): ... self . x = x ... ... class X : ... pass ... ... # Names. ... foo , bar , baz , x = Foo , Bar , Baz , X >>> Container . foo . check () True >>> Container . bar . x is Container . bar . x False Nested Injectors \u00b6 It is possible to inject Injector itself. Injector subclasses are provided as is, and calculate their attributes on first use. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar ): ... self . bar = bar ... ... def __call__ ( self ): ... return self . bar . baz () ... ... class Bar ( Injector ): ... ... class Baz : ... ... def __init__ ( self , func ): ... self . func = func ... ... def __call__ ( self ): ... return self . func () ... ... def func (): ... return 1 ... ... # Names. ... baz = Baz ... ... # Names. ... foo , bar = Foo , Bar >>> Container . foo () 1 >>> Container . foo . bar <class '_dependencies.injector.Bar'> >>> Container . foo . bar . baz # doctest: +ELLIPSIS <__main__.Container.Bar.Baz object at 0x...> >>> Container . foo . bar . baz . func # doctest: +ELLIPSIS <function Container.Bar.func at 0x...> >>> Container . foo . bar . baz . func () 1 Scope extension \u00b6 You can define a dependency scope partially and then extend it; only in injection moment, meaning at the time of attribute access, you are required to have the complete scope. It is possible to extend dependency scopes in two ways: inheritance call Inheritance \u00b6 You can add additional dependencies or redefine existing ones in a scope subclass: >>> class Foo : ... pass >>> class Scope ( Injector ): ... foo = Foo >>> class ChildScope ( Scope ): ... bar = Bar >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> Multiple inheritance is allowed as well. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> class ChildScope ( Scope1 , Scope2 ): ... pass >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> We also provide and notation for in-place Injector composition. Example below is full equivalent to the previous one, but without intermediate class needed. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> ( Scope1 & Scope2 ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> Note Extension scope should not be empty. You can't inherit from Injector just to have pass keyword as the body of the class. >>> class Container ( Injector ): ... pass Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Extension scope can not be empty Call \u00b6 You can temporary redefine a dependency for only one case. This is extremely useful for tests. Inject an assertion instead of one or more dependencies, and you will be able to test your system in all possible cases. It is, for example, possible to simulate database integrity error on concurrent access. >>> class Scope ( Injector ): ... foo = Foo ... bar = Bar >>> Scope ( bar = Baz ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> It is possible to build dependency scopes directly from dictionaries using call. >>> settings = { 'host' : 'localhost' , 'port' : 1234 } >>> Scope = Injector ( foo = Foo , bar = Bar , ** settings ) hasattr alternative \u00b6 hasattr works by attribute access, so it triggers dependency injection. If this is unnecessary side effect, dependencies provides alternative way. >>> class Container ( Injector ): ... foo = 1 >>> 'foo' in Container True \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#preparations","text":"Before we start to inject dependencies, let's define code which needs these dependencies. Also, let's add some behavior to your robot. >>> class Robot : ... def __init__ ( self , servo , controller , settings ): ... self . servo = servo ... self . controller = controller ... self . settings = settings ... ... def run ( self ): ... while True : ... events = self . accept_events () ... if not events : ... break ... self . process ( events ) ... ... def accept_events ( self ): ... # We can inject methods. ... return self . controller () ... ... def process ( self , events ): ... # We can inject dictionaries. ... max_point = self . settings [ \"max_point\" ] ... for event in events : ... if event . x > max_point : ... # We can inject objects. ... self . servo . reverse ( \"x\" ) ... if event . y > max_point : ... self . servo . reverse ( \"y\" ) We use constructor-based dependency injection here: we define necessary arguments and store them explicitly, for the sake of readability. This will help us to understand the execution path of your system. Attributes sourced from nowhere in your code aren't fun. Believe me. Now, it's time to make this work in the real world. >>> class MechanicalMotor : ... def reverse ( self , coordinate ): ... # Hardware work goes here. ... pass >>> def read_sensor (): ... # Another hardware work goes here. ... return [] >>> production = { 'max_point' : 0.01 } We are close to scream \"It's alive!\" and, if we're lucky enough, run out of the building. >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = MechanicalMotor ... controller = read_sensor ... settings = production >>> robot = Container . robot # Robots' constructor called here. >>> robot . run () Congratulations! We've built our robot with dependency injection.","title":"Preparations"},{"location":"usage/#injection-rules","text":"Container above is a dependency scope, and dependencies are defined as its attributes. When you access one of those attributes, the following happens: If attribute value is a class , it will be instantiated. To make that possible, the library will inspect its constructor's argument list and search current dependency scope for dependencies with the same name. If attribute value is a class but attribute name ends with _class - then it will be returned as is. (For example, Container.foo_class will return the class stored in it, not its instance). Anything else is returned as is. If, during dependency search, we encounter another class - it will be instantiated along these rules, as well. The process is recursive. Here is a demonstration of rules above. >>> class Foo : ... def __init__ ( self , one , two ): ... self . one = one ... self . two = two >>> class Bar : ... pass >>> class Baz : ... def __init__ ( self , x ): ... self . x = x >>> from dependencies import Injector >>> class Scope ( Injector ): ... foo = Foo ... one = Bar ... two = Baz ... x = 1 >>> Scope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> >>> Scope . foo . one # doctest: +ELLIPSIS <__main__.Bar object at 0x...> >>> Scope . foo . two # doctest: +ELLIPSIS <__main__.Baz object at 0x...> >>> Scope . foo . two . x 1 Let's roll down what is happening here: Foo class requires an argument named two ; In dependency scope, that argument resolves to Baz class; Which is a class - oh, we need to instantiate it as well; But its constructor requires an argument named x ; Which resolves to 1 in the dependency scope, so we do not need to go any further. Having found that out, we effectively construct, execute, and return Foo(two=Baz(x=1)) .","title":"Injection rules"},{"location":"usage/#calculation-rules","text":"Each dependency evaluates exactly once during injection process. If during dependency injection different classes have constructor argument with the same name, the corresponding dependency will be instantiated once and these two constructors will receive the same object. But this object only lives during one injection process; another attribute access means a new object. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar , baz ): ... self . bar = bar ... self . baz = baz ... ... def check ( self ): ... return self . bar . x is self . baz . x ... ... class Bar : ... ... def __init__ ( self , x ): ... self . x = x ... ... class Baz : ... ... def __init__ ( self , x ): ... self . x = x ... ... class X : ... pass ... ... # Names. ... foo , bar , baz , x = Foo , Bar , Baz , X >>> Container . foo . check () True >>> Container . bar . x is Container . bar . x False","title":"Calculation rules"},{"location":"usage/#nested-injectors","text":"It is possible to inject Injector itself. Injector subclasses are provided as is, and calculate their attributes on first use. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar ): ... self . bar = bar ... ... def __call__ ( self ): ... return self . bar . baz () ... ... class Bar ( Injector ): ... ... class Baz : ... ... def __init__ ( self , func ): ... self . func = func ... ... def __call__ ( self ): ... return self . func () ... ... def func (): ... return 1 ... ... # Names. ... baz = Baz ... ... # Names. ... foo , bar = Foo , Bar >>> Container . foo () 1 >>> Container . foo . bar <class '_dependencies.injector.Bar'> >>> Container . foo . bar . baz # doctest: +ELLIPSIS <__main__.Container.Bar.Baz object at 0x...> >>> Container . foo . bar . baz . func # doctest: +ELLIPSIS <function Container.Bar.func at 0x...> >>> Container . foo . bar . baz . func () 1","title":"Nested Injectors"},{"location":"usage/#scope-extension","text":"You can define a dependency scope partially and then extend it; only in injection moment, meaning at the time of attribute access, you are required to have the complete scope. It is possible to extend dependency scopes in two ways: inheritance call","title":"Scope extension"},{"location":"usage/#inheritance","text":"You can add additional dependencies or redefine existing ones in a scope subclass: >>> class Foo : ... pass >>> class Scope ( Injector ): ... foo = Foo >>> class ChildScope ( Scope ): ... bar = Bar >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> Multiple inheritance is allowed as well. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> class ChildScope ( Scope1 , Scope2 ): ... pass >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> We also provide and notation for in-place Injector composition. Example below is full equivalent to the previous one, but without intermediate class needed. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> ( Scope1 & Scope2 ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> Note Extension scope should not be empty. You can't inherit from Injector just to have pass keyword as the body of the class. >>> class Container ( Injector ): ... pass Traceback (most recent call last): ... _dependencies.exceptions.DependencyError : Extension scope can not be empty","title":"Inheritance"},{"location":"usage/#call","text":"You can temporary redefine a dependency for only one case. This is extremely useful for tests. Inject an assertion instead of one or more dependencies, and you will be able to test your system in all possible cases. It is, for example, possible to simulate database integrity error on concurrent access. >>> class Scope ( Injector ): ... foo = Foo ... bar = Bar >>> Scope ( bar = Baz ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> It is possible to build dependency scopes directly from dictionaries using call. >>> settings = { 'host' : 'localhost' , 'port' : 1234 } >>> Scope = Injector ( foo = Foo , bar = Bar , ** settings )","title":"Call"},{"location":"usage/#hasattr-alternative","text":"hasattr works by attribute access, so it triggers dependency injection. If this is unnecessary side effect, dependencies provides alternative way. >>> class Container ( Injector ): ... foo = 1 >>> 'foo' in Container True \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"hasattr alternative"},{"location":"value/","text":"value object \u00b6 Value object gives you the way to execute code during dependency injection process. If dependency injection process needs to resolve value object, a decorated function will be called. Result of it's execution will be used as resolved dependency under value object name. Returned value treated as is without further processing. Classes returned by @value decorated function would be be used as classes. It will not be treated as something we need instantiate. Value object will be stored in the injection scope under the same name as decorated function. Arguments of the decorated function will be treated as direct dependencies of the @value object. Each argument will be resolved from the same injection scope where value object was defined. Example \u00b6 >>> from dependencies import Injector , value >>> class Container ( Injector ): ... foo = 1 ... bar = 2 ... baz = 3 ... ... @value ... def quiz ( foo , bar , baz ): ... return foo + bar + baz >>> Container . quiz 6 As you can see, foo , bar , and baz were resolved from the Container injection scope. After that quiz function was called with resolved dependencies passed to its arguments. Result of the function was stored in the injection scope under the same quiz name. We received value from quiz name from the injection scope. Depending on the value \u00b6 >>> class Foo : ... def __init__ ( self , quiz ): ... self . quiz = quiz >>> class Bar : ... def __init__ ( self , quiz ): ... self . quiz = quiz >>> class Baz : ... def __init__ ( self , foo , bar ): ... self . foo = foo ... self . bar = bar >>> class Container ( Injector ): ... foo = Foo ... bar = Bar ... baz = Baz ... ... @value ... def quiz (): ... print ( 'value executed' ) ... return 3 >>> baz = Container . baz value executed >>> baz . foo . quiz 3 >>> baz . bar . quiz 3 You may depend on the @value object value the same way you depend on regular instances of the class. In the example above Foo and Bar depends on quiz name. Value object would be resolved to 3 (result returned by decorated function) and this value would be injected in corresponding argument of Foo and Bar constructors. As you can see @value decorated function was called only once even two objects depends on it. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Value"},{"location":"value/#value-object","text":"Value object gives you the way to execute code during dependency injection process. If dependency injection process needs to resolve value object, a decorated function will be called. Result of it's execution will be used as resolved dependency under value object name. Returned value treated as is without further processing. Classes returned by @value decorated function would be be used as classes. It will not be treated as something we need instantiate. Value object will be stored in the injection scope under the same name as decorated function. Arguments of the decorated function will be treated as direct dependencies of the @value object. Each argument will be resolved from the same injection scope where value object was defined.","title":"value object"},{"location":"value/#example","text":">>> from dependencies import Injector , value >>> class Container ( Injector ): ... foo = 1 ... bar = 2 ... baz = 3 ... ... @value ... def quiz ( foo , bar , baz ): ... return foo + bar + baz >>> Container . quiz 6 As you can see, foo , bar , and baz were resolved from the Container injection scope. After that quiz function was called with resolved dependencies passed to its arguments. Result of the function was stored in the injection scope under the same quiz name. We received value from quiz name from the injection scope.","title":"Example"},{"location":"value/#depending-on-the-value","text":">>> class Foo : ... def __init__ ( self , quiz ): ... self . quiz = quiz >>> class Bar : ... def __init__ ( self , quiz ): ... self . quiz = quiz >>> class Baz : ... def __init__ ( self , foo , bar ): ... self . foo = foo ... self . bar = bar >>> class Container ( Injector ): ... foo = Foo ... bar = Bar ... baz = Baz ... ... @value ... def quiz (): ... print ( 'value executed' ) ... return 3 >>> baz = Container . baz value executed >>> baz . foo . quiz 3 >>> baz . bar . quiz 3 You may depend on the @value object value the same way you depend on regular instances of the class. In the example above Foo and Bar depends on quiz name. Value object would be resolved to 3 (result returned by decorated function) and this value would be injected in corresponding argument of Foo and Bar constructors. As you can see @value decorated function was called only once even two objects depends on it. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Depending on the value"},{"location":"why/","text":"Why not\u2026 \u00b6 Here we will try to collect pros and cons of different approaches to make your code extendable and reusable. Let's imagine we have an order processing system. We want to implement order purchase feature. It is a lot of functionality to be built: We should change our data, send a request to the payment processing system, and we should send notification to the user. Simple functions \u00b6 Let's do it with simple functions. >>> def purchase ( user , product , shipment_details ): ... order = create_order ( user , product ) ... final_price = calculate_price ( order , shipment_details ) ... payment_details = request_payment ( user , shipment_details ) ... notify_user ( user , payment_details ) >>> def notify_user ( user , payment_details ): ... log_notification ( user , payment_details ) ... subject = get_notification_subject ( payment_details ) ... message = get_notification_text ( user , payment_details ) ... send_notification ( user , subject , message ) >>> def send_notification ( user , subject , message ): ... email = get_user_email ( user ) ... send_email ( email , subject , message ) It's a readable and straightforward solution. What can possibly go wrong? Problem is that this code is difficult to change and extend. For example, you need to add SMS and push notifications in addition to plain text emails. To do that, you'll have to add a handful of different conditions to this simple default path. Push notification to the mobile app should be written in Markdown format, SMS requires plain text, and email needs HTML in addition to plain text. Users should be able to choose their preferred notification method. How can we change the code above to match new requirements? We have problems on all three layers of the code: purchase , notify_user and send_notification functions have to be changed. Add conditions to all parameters to all layers of the code. This will end up with messy code which is even harder to extend. No one wants purchase function to have 12 arguments. No one wants to wonder why send_email function accepts phone number. No one wants to read 7 if statements in the notify_user function when they are about to add eighth condition. Add context variable instead of another argument. This little ctx argument instead of email address, phone number, product price and shipment destination will save us a lot of typing between function calls. Unfortunately, we still have bunch of if statements. Copy-paste this module and re-implement each feature separately. Each feature will be readable and simple on it's own, but you will regret this decision when usage of request_payment or calculate_price changes. Unfortunately, we still have the same problem. We can't substitute implementation details of low level code without changing high level policies. Let's try\u2026 Inheritance \u00b6 Let's rewrite our functions into a class which we can subclass for different purposes. >>> class Order : ... ... def __init__ ( self , user , product , shipment_details ): ... ... self . user = user ... self . product = product ... self . shipment_details = shipment_details ... self . final_price = None # Set by `calculate_price`. ... self . payment_details = None # Set by `request_payment`. ... self . subject = None # Set by `get_notification_subject`. ... self . message = None # Set by `get_notification_text`. ... self . email = None # Set by `get_user_email`. ... ... def purchase ( self ): ... ... self . create_order () ... self . calculate_price () ... self . request_payment () ... self . notify_user () ... ... def notify_user ( self ): ... ... self . log_notification () ... self . get_notification_subject () ... self . get_notification_text () ... self . send_notification () ... ... def send_notification ( self ): ... ... self . get_user_email () ... self . send_email () At first glance, this class is a better solution than before. Indeed, this code has several advantages. At first glance high level methods even more readable. Noisy arguments and variables went away. Only methods with nice names stayed. Simple code reuse. With inheritance, we can override any method on any layer of abstraction in the system. We can add any number of methods or attributes is the child classes. Looks like it is a reasonable approach. Unfortunately, this code hides quite a few problems underneath the false premise of understandability and cleanness. God object. One class contains methods related to every single layer of abstraction in the system. It's hard to manage two hundred methods in the same class: one will process HTTP request, another one will send email, and yet another one will write to the database. It's hard to figure out what exactly this class does. Bad state management. During the life time of a class instance different methods change state of the class. When you read short method somewhere inside email sender logic, you have no idea from where attribute values came from and when exactly they were set. Hello print statements to understand the code\u2026 Let's reduce amount of logic in the class (responsibility of the class). Let's try\u2026 Mixins \u00b6 We can split our God object into multiple classes and join it together later using multiple inheritance. >>> class OrderProcessingMixin : ... ... def create_order ( self ): ... ... pass >>> class PriceCalculationMixin : ... ... def calculate_price ( self ): ... ... pass >>> class NotificationMixin : ... ... def get_notification_text ( self ): ... ... self . notification_text = self . notification_text_template % ( ... self . user , ... self . payment_details , ... ) >>> class Order ( OrderProcessingMixin , ... PriceCalculationMixin , ... NotificationMixin ): ... ... def before_calculate ( self ): ... ... self . create_order () ... ... def after_commit ( self ): ... ... self . send_email () Someone might say this is an improvement over one huge class. All methods grouped in classes with the same responsibility. Better code reuse. We can use the same notification mechanism in different classes with just one line of code. Unfortunately, there are a lot of problems too. During a debugging session, In the get_notification_text you have no idea who set up payment_details . In the Order class itself you see a bunch of low level methods which are deep implementation details. What public method should I call? When notification will be sent, exactly? This code is much harder to understand than it should be. Even if it reusable, this complexity in too large for my head. Let's try\u2026 Composition \u00b6 Composition is a powerful pattern of organizing code with proper code boundaries and clear dependency relationship. >>> class OrderProcessor : ... ... def create ( self , user , product ): ... ... pass >>> class PriceCalculator : ... ... def calculate ( self , product , shipment_details ): ... ... pass >>> class PaymentProcessor : ... ... def request ( self , user , shipment_details ): ... ... pass >>> class Notification : ... ... def __init__ ( self , logger ): ... ... self . logger = logger ... ... def notify ( self , user , payment_details ): ... ... self . logger . record ( user , payment_details ) ... subject = self . get_notification_subject ( payment_details ) ... message = self . get_notification_text ( user , payment_details ) ... self . send_notification ( user , subject , message ) ... ... def get_notification_subject ( self , payment_details ): ... ... pass ... ... def get_notification_text ( self , user , payment_details ): ... ... pass ... ... def send_notification ( self , user , subject , message ): ... ... pass >>> class Order : ... ... def __init__ ( self , order_processor , price_calculator , ... payment_processor , notification ): ... ... self . order_processor = order_processor ... self . price_calculator = price_calculator ... self . payment_processor = payment_processor ... self . notification = notification ... ... def purchase ( self , user , product , shipment_details ): ... ... self . order_processor . create ( user , product ) ... final_price = self . price_calculator . calculate ( product , shipment_details ) ... payment_details = self . payment_processor . request ( user , shipment_details ) ... self . notification . notify ( user , payment_details ) >>> from app.shop import Logger , User , Product , ShipmentDetails >>> Order ( ... OrderProcessor (), ... PriceCalculator (), ... PaymentProcessor (), ... Notification ( Logger ()), ... ) . purchase ( User (), Product (), ShipmentDetails ()) This code has a number of really good characteristics. It's clear where things were defined. If you try to understand what's wrong with your system, you can just use traceback. No nasty code execution paths. Your system becomes really configurable. You can inject pretty much any implementation without changing high-level code. Unfortunately, there one unfortunate consequence of this style It is too much boilerplate on the initiation stage. Let's try\u2026 Dependencies \u00b6 Here's where dependencies library comes in. >>> from dependencies import Injector >>> class OrderContainer ( Injector ): ... ... order = Order ... order_processor = OrderProcessor ... price_calculator = PriceCalculator ... payment_processor = PaymentProcessor ... notification = Notification ... logger = Logger >>> OrderContainer . order . purchase ( User (), Product (), ShipmentDetails ()) It helps you to reduce the boilerplate of the initiation stage. It doesn't require you to change your code. You still can instantiate your classes directly, if you don't like this library. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Why"},{"location":"why/#why-not","text":"Here we will try to collect pros and cons of different approaches to make your code extendable and reusable. Let's imagine we have an order processing system. We want to implement order purchase feature. It is a lot of functionality to be built: We should change our data, send a request to the payment processing system, and we should send notification to the user.","title":"Why not\u2026"},{"location":"why/#simple-functions","text":"Let's do it with simple functions. >>> def purchase ( user , product , shipment_details ): ... order = create_order ( user , product ) ... final_price = calculate_price ( order , shipment_details ) ... payment_details = request_payment ( user , shipment_details ) ... notify_user ( user , payment_details ) >>> def notify_user ( user , payment_details ): ... log_notification ( user , payment_details ) ... subject = get_notification_subject ( payment_details ) ... message = get_notification_text ( user , payment_details ) ... send_notification ( user , subject , message ) >>> def send_notification ( user , subject , message ): ... email = get_user_email ( user ) ... send_email ( email , subject , message ) It's a readable and straightforward solution. What can possibly go wrong? Problem is that this code is difficult to change and extend. For example, you need to add SMS and push notifications in addition to plain text emails. To do that, you'll have to add a handful of different conditions to this simple default path. Push notification to the mobile app should be written in Markdown format, SMS requires plain text, and email needs HTML in addition to plain text. Users should be able to choose their preferred notification method. How can we change the code above to match new requirements? We have problems on all three layers of the code: purchase , notify_user and send_notification functions have to be changed. Add conditions to all parameters to all layers of the code. This will end up with messy code which is even harder to extend. No one wants purchase function to have 12 arguments. No one wants to wonder why send_email function accepts phone number. No one wants to read 7 if statements in the notify_user function when they are about to add eighth condition. Add context variable instead of another argument. This little ctx argument instead of email address, phone number, product price and shipment destination will save us a lot of typing between function calls. Unfortunately, we still have bunch of if statements. Copy-paste this module and re-implement each feature separately. Each feature will be readable and simple on it's own, but you will regret this decision when usage of request_payment or calculate_price changes. Unfortunately, we still have the same problem. We can't substitute implementation details of low level code without changing high level policies. Let's try\u2026","title":"Simple functions"},{"location":"why/#inheritance","text":"Let's rewrite our functions into a class which we can subclass for different purposes. >>> class Order : ... ... def __init__ ( self , user , product , shipment_details ): ... ... self . user = user ... self . product = product ... self . shipment_details = shipment_details ... self . final_price = None # Set by `calculate_price`. ... self . payment_details = None # Set by `request_payment`. ... self . subject = None # Set by `get_notification_subject`. ... self . message = None # Set by `get_notification_text`. ... self . email = None # Set by `get_user_email`. ... ... def purchase ( self ): ... ... self . create_order () ... self . calculate_price () ... self . request_payment () ... self . notify_user () ... ... def notify_user ( self ): ... ... self . log_notification () ... self . get_notification_subject () ... self . get_notification_text () ... self . send_notification () ... ... def send_notification ( self ): ... ... self . get_user_email () ... self . send_email () At first glance, this class is a better solution than before. Indeed, this code has several advantages. At first glance high level methods even more readable. Noisy arguments and variables went away. Only methods with nice names stayed. Simple code reuse. With inheritance, we can override any method on any layer of abstraction in the system. We can add any number of methods or attributes is the child classes. Looks like it is a reasonable approach. Unfortunately, this code hides quite a few problems underneath the false premise of understandability and cleanness. God object. One class contains methods related to every single layer of abstraction in the system. It's hard to manage two hundred methods in the same class: one will process HTTP request, another one will send email, and yet another one will write to the database. It's hard to figure out what exactly this class does. Bad state management. During the life time of a class instance different methods change state of the class. When you read short method somewhere inside email sender logic, you have no idea from where attribute values came from and when exactly they were set. Hello print statements to understand the code\u2026 Let's reduce amount of logic in the class (responsibility of the class). Let's try\u2026","title":"Inheritance"},{"location":"why/#mixins","text":"We can split our God object into multiple classes and join it together later using multiple inheritance. >>> class OrderProcessingMixin : ... ... def create_order ( self ): ... ... pass >>> class PriceCalculationMixin : ... ... def calculate_price ( self ): ... ... pass >>> class NotificationMixin : ... ... def get_notification_text ( self ): ... ... self . notification_text = self . notification_text_template % ( ... self . user , ... self . payment_details , ... ) >>> class Order ( OrderProcessingMixin , ... PriceCalculationMixin , ... NotificationMixin ): ... ... def before_calculate ( self ): ... ... self . create_order () ... ... def after_commit ( self ): ... ... self . send_email () Someone might say this is an improvement over one huge class. All methods grouped in classes with the same responsibility. Better code reuse. We can use the same notification mechanism in different classes with just one line of code. Unfortunately, there are a lot of problems too. During a debugging session, In the get_notification_text you have no idea who set up payment_details . In the Order class itself you see a bunch of low level methods which are deep implementation details. What public method should I call? When notification will be sent, exactly? This code is much harder to understand than it should be. Even if it reusable, this complexity in too large for my head. Let's try\u2026","title":"Mixins"},{"location":"why/#composition","text":"Composition is a powerful pattern of organizing code with proper code boundaries and clear dependency relationship. >>> class OrderProcessor : ... ... def create ( self , user , product ): ... ... pass >>> class PriceCalculator : ... ... def calculate ( self , product , shipment_details ): ... ... pass >>> class PaymentProcessor : ... ... def request ( self , user , shipment_details ): ... ... pass >>> class Notification : ... ... def __init__ ( self , logger ): ... ... self . logger = logger ... ... def notify ( self , user , payment_details ): ... ... self . logger . record ( user , payment_details ) ... subject = self . get_notification_subject ( payment_details ) ... message = self . get_notification_text ( user , payment_details ) ... self . send_notification ( user , subject , message ) ... ... def get_notification_subject ( self , payment_details ): ... ... pass ... ... def get_notification_text ( self , user , payment_details ): ... ... pass ... ... def send_notification ( self , user , subject , message ): ... ... pass >>> class Order : ... ... def __init__ ( self , order_processor , price_calculator , ... payment_processor , notification ): ... ... self . order_processor = order_processor ... self . price_calculator = price_calculator ... self . payment_processor = payment_processor ... self . notification = notification ... ... def purchase ( self , user , product , shipment_details ): ... ... self . order_processor . create ( user , product ) ... final_price = self . price_calculator . calculate ( product , shipment_details ) ... payment_details = self . payment_processor . request ( user , shipment_details ) ... self . notification . notify ( user , payment_details ) >>> from app.shop import Logger , User , Product , ShipmentDetails >>> Order ( ... OrderProcessor (), ... PriceCalculator (), ... PaymentProcessor (), ... Notification ( Logger ()), ... ) . purchase ( User (), Product (), ShipmentDetails ()) This code has a number of really good characteristics. It's clear where things were defined. If you try to understand what's wrong with your system, you can just use traceback. No nasty code execution paths. Your system becomes really configurable. You can inject pretty much any implementation without changing high-level code. Unfortunately, there one unfortunate consequence of this style It is too much boilerplate on the initiation stage. Let's try\u2026","title":"Composition"},{"location":"why/#dependencies","text":"Here's where dependencies library comes in. >>> from dependencies import Injector >>> class OrderContainer ( Injector ): ... ... order = Order ... order_processor = OrderProcessor ... price_calculator = PriceCalculator ... payment_processor = PaymentProcessor ... notification = Notification ... logger = Logger >>> OrderContainer . order . purchase ( User (), Product (), ShipmentDetails ()) It helps you to reduce the boilerplate of the initiation stage. It doesn't require you to change your code. You still can instantiate your classes directly, if you don't like this library. \u2014 \u2b50 \u2014 The dependencies library is part of the SOLID python family.","title":"Dependencies"}]}