{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dependencies \u00b6 Dependency Injection for Humans. Documentation | Source Code | Task Tracker Dependency Injection (or simply DI) is a great technique. By using it you can organize responsibilities in you codebase. Define high level policies and system behavior in one part. Delegate control to low level mechanisms in another part. Simple and powerful. With help of DI you can use different parts of your system independently and combine their behavior really easy. If you split logic and implementation into different classes, you will see how pleasant it becomes to change your system. This tiny library helps you to connect parts of your system, in particular - to inject low level implementation into high level behavior. Pros \u00b6 Provide composition instead of inheritance. Solves top-down architecture problems. Boilerplate-free object hierarchies. API entrypoints, admin panels, CLI commands are oneliners. Example \u00b6 Dependency injection without dependencies >>> from app.robot import Robot , Servo , Amplifier , Controller , Settings >>> robot = Robot ( ... servo = Servo ( amplifier = Amplifier ()), ... controller = Controller (), ... settings = Settings ( environment = \"production\" ), ... ) >>> robot . work () Dependency injection with dependencies >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = Servo ... amplifier = Amplifier ... controller = Controller ... settings = Settings ... environment = \"production\" >>> Container . robot . work () Questions \u00b6 If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose. License \u00b6 Dependencies library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Home"},{"location":"#dependencies","text":"Dependency Injection for Humans. Documentation | Source Code | Task Tracker Dependency Injection (or simply DI) is a great technique. By using it you can organize responsibilities in you codebase. Define high level policies and system behavior in one part. Delegate control to low level mechanisms in another part. Simple and powerful. With help of DI you can use different parts of your system independently and combine their behavior really easy. If you split logic and implementation into different classes, you will see how pleasant it becomes to change your system. This tiny library helps you to connect parts of your system, in particular - to inject low level implementation into high level behavior.","title":"Dependencies"},{"location":"#pros","text":"Provide composition instead of inheritance. Solves top-down architecture problems. Boilerplate-free object hierarchies. API entrypoints, admin panels, CLI commands are oneliners.","title":"Pros"},{"location":"#example","text":"Dependency injection without dependencies >>> from app.robot import Robot , Servo , Amplifier , Controller , Settings >>> robot = Robot ( ... servo = Servo ( amplifier = Amplifier ()), ... controller = Controller (), ... settings = Settings ( environment = \"production\" ), ... ) >>> robot . work () Dependency injection with dependencies >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = Servo ... amplifier = Amplifier ... controller = Controller ... settings = Settings ... environment = \"production\" >>> Container . robot . work ()","title":"Example"},{"location":"#questions","text":"If you have any questions, feel free to create an issue in our Task Tracker . We have the question label exactly for this purpose.","title":"Questions"},{"location":"#license","text":"Dependencies library is offered under the two clause BSD license. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"License"},{"location":"attrs/","text":"Using attrs \u00b6 attrs is the Python package that will bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods). It's an excellent library. Personally, I use it heavily in all projects. Inject classes \u00b6 Here is an example of how to use it together with dependencies . >>> from attr import attrs , attrib >>> from dependencies import Injector >>> @attrs ... class Order ( object ): ... price = attrib () ... items = attrib () >>> class Container ( Injector ): ... order = Order ... price = ( 799 , 99 ) ... items = [ \"amplifier\" , \"servo\" ] >>> Container . order Order(price=(799, 99), items=['amplifier', 'servo']) As you can see, instances of a class defined with attrs are built completely the same way we build handwritten classes. But there is no need to write all this boilerplate by hand. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Attrs"},{"location":"attrs/#using-attrs","text":"attrs is the Python package that will bring back the joy of writing classes by relieving you from the drudgery of implementing object protocols (aka dunder methods). It's an excellent library. Personally, I use it heavily in all projects.","title":"Using attrs"},{"location":"attrs/#inject-classes","text":"Here is an example of how to use it together with dependencies . >>> from attr import attrs , attrib >>> from dependencies import Injector >>> @attrs ... class Order ( object ): ... price = attrib () ... items = attrib () >>> class Container ( Injector ): ... order = Order ... price = ( 799 , 99 ) ... items = [ \"amplifier\" , \"servo\" ] >>> Container . order Order(price=(799, 99), items=['amplifier', 'servo']) As you can see, instances of a class defined with attrs are built completely the same way we build handwritten classes. But there is no need to write all this boilerplate by hand. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Inject classes"},{"location":"changelog/","text":"2.0.1 (2020-07-16) \u00b6 Bug Fixes \u00b6 compatibility with typing module on Python 3.6 ( 137741f ) 2.0.0 (2020-05-17) \u00b6 Features \u00b6 remove contrib package ( 5bfe041 ), closes #192 BREAKING CHANGES \u00b6 Every time a new user asks me how to use their favorite framework together with stories and dependencies I understand that there is a missing module in the contrib package. 1.0.1 (2020-03-31) \u00b6 Bug Fixes \u00b6 add wrapped attribute ( e3c7aa9 ) 1.0.0 (2020-02-11) \u00b6 Bug Fixes \u00b6 prevent generated changelog from style guide violation ( d3a472f ) 0.15 (2018-07-21) \u00b6 Support in checks in the Injector subclasses. Add operation decorator to build injectable functions. Add Package proxy to reduce import boilerplate in the Injector definition. Add Celery contrib to define tasks from Injector subclasses. Add Py.Test contrib to define fixtures from Injector subclasses. Add Django contrib to define views from Injector subclasses. Add Django REST Framework contrib to define API views and model view sets from Injector subclasses. A class named attributes should end with _class . Improved error messages for missing dependencies. Raise DependencyError instead of AttributeError for missed dependencies. Drop python 2.6 and 3.4 support. 0.14 (2018-04-13) \u00b6 Add this proxy object for aliases and cross injector links. Deprecate attribute assignment and use decorator. Release under BSD license. 0.13 (2016-10-09) \u00b6 Performance improvements. 0.12 (2016-09-29) \u00b6 Allow multiple inheritance for Injector subclasses. Evaluate dependencies once. Add use decorator. Allow nested injectors. 0.11 (2016-08-22) \u00b6 Twelve times speed up. Protect from incorrect operations with attribute assignment. Deny *args and **kwargs in the injectable classes. Classes can be used as default argument values only if argument name ends with _cls . Remove six library from install requires. 0.10 (2016-06-09) \u00b6 Turn into module. 0.9 (2016-06-08) \u00b6 Dependency assignment and cancellation for Injector subclasses. 0.8 (2016-06-05) \u00b6 Correct syntax error for Python 2.6 0.7 (2016-06-04) \u00b6 Raise DependencyError for mutual recursion in constructor arguments and specified dependencies. Show injected dependencies in the dir result. Deny to instantiate Injector and its subclasses. 0.6 (2016-03-09) \u00b6 Deprecate c alias. Use real classes. Allow to use let directly on Injector . Do not instantiate dependencies named with cls at the end. 0.5 (2016-03-03) \u00b6 Avoid attribute search recursion. This occurs with inheritance chain length started at 3 and missing dependency on first level. Add c alias for Injector subclass access. Add let factory to temporarily overwrite specified dependencies. 0.4 (2016-03-03) \u00b6 Detect object.__init__ and skip it in the argument injection. 0.3 (2016-03-02) \u00b6 Deprecate injectable mechanism. Injector may inject any arguments to any classes. Injector now support multiple DI targets. All possible targets now specified in the Injector attributes. Only single base inheritance allowed for Injector subclasses. 0.2 (2016-02-13) \u00b6 Allows to override dependencies specified with Injector by inheritance from this Injector subclass. 0.1 (2016-01-31) \u00b6 Initial release. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#201-2020-07-16","text":"","title":"2.0.1 (2020-07-16)"},{"location":"changelog/#bug-fixes","text":"compatibility with typing module on Python 3.6 ( 137741f )","title":"Bug Fixes"},{"location":"changelog/#200-2020-05-17","text":"","title":"2.0.0 (2020-05-17)"},{"location":"changelog/#features","text":"remove contrib package ( 5bfe041 ), closes #192","title":"Features"},{"location":"changelog/#breaking-changes","text":"Every time a new user asks me how to use their favorite framework together with stories and dependencies I understand that there is a missing module in the contrib package.","title":"BREAKING CHANGES"},{"location":"changelog/#101-2020-03-31","text":"","title":"1.0.1 (2020-03-31)"},{"location":"changelog/#bug-fixes_1","text":"add wrapped attribute ( e3c7aa9 )","title":"Bug Fixes"},{"location":"changelog/#100-2020-02-11","text":"","title":"1.0.0 (2020-02-11)"},{"location":"changelog/#bug-fixes_2","text":"prevent generated changelog from style guide violation ( d3a472f )","title":"Bug Fixes"},{"location":"changelog/#015-2018-07-21","text":"Support in checks in the Injector subclasses. Add operation decorator to build injectable functions. Add Package proxy to reduce import boilerplate in the Injector definition. Add Celery contrib to define tasks from Injector subclasses. Add Py.Test contrib to define fixtures from Injector subclasses. Add Django contrib to define views from Injector subclasses. Add Django REST Framework contrib to define API views and model view sets from Injector subclasses. A class named attributes should end with _class . Improved error messages for missing dependencies. Raise DependencyError instead of AttributeError for missed dependencies. Drop python 2.6 and 3.4 support.","title":"0.15 (2018-07-21)"},{"location":"changelog/#014-2018-04-13","text":"Add this proxy object for aliases and cross injector links. Deprecate attribute assignment and use decorator. Release under BSD license.","title":"0.14 (2018-04-13)"},{"location":"changelog/#013-2016-10-09","text":"Performance improvements.","title":"0.13 (2016-10-09)"},{"location":"changelog/#012-2016-09-29","text":"Allow multiple inheritance for Injector subclasses. Evaluate dependencies once. Add use decorator. Allow nested injectors.","title":"0.12 (2016-09-29)"},{"location":"changelog/#011-2016-08-22","text":"Twelve times speed up. Protect from incorrect operations with attribute assignment. Deny *args and **kwargs in the injectable classes. Classes can be used as default argument values only if argument name ends with _cls . Remove six library from install requires.","title":"0.11 (2016-08-22)"},{"location":"changelog/#010-2016-06-09","text":"Turn into module.","title":"0.10 (2016-06-09)"},{"location":"changelog/#09-2016-06-08","text":"Dependency assignment and cancellation for Injector subclasses.","title":"0.9 (2016-06-08)"},{"location":"changelog/#08-2016-06-05","text":"Correct syntax error for Python 2.6","title":"0.8 (2016-06-05)"},{"location":"changelog/#07-2016-06-04","text":"Raise DependencyError for mutual recursion in constructor arguments and specified dependencies. Show injected dependencies in the dir result. Deny to instantiate Injector and its subclasses.","title":"0.7 (2016-06-04)"},{"location":"changelog/#06-2016-03-09","text":"Deprecate c alias. Use real classes. Allow to use let directly on Injector . Do not instantiate dependencies named with cls at the end.","title":"0.6 (2016-03-09)"},{"location":"changelog/#05-2016-03-03","text":"Avoid attribute search recursion. This occurs with inheritance chain length started at 3 and missing dependency on first level. Add c alias for Injector subclass access. Add let factory to temporarily overwrite specified dependencies.","title":"0.5 (2016-03-03)"},{"location":"changelog/#04-2016-03-03","text":"Detect object.__init__ and skip it in the argument injection.","title":"0.4 (2016-03-03)"},{"location":"changelog/#03-2016-03-02","text":"Deprecate injectable mechanism. Injector may inject any arguments to any classes. Injector now support multiple DI targets. All possible targets now specified in the Injector attributes. Only single base inheritance allowed for Injector subclasses.","title":"0.3 (2016-03-02)"},{"location":"changelog/#02-2016-02-13","text":"Allows to override dependencies specified with Injector by inheritance from this Injector subclass.","title":"0.2 (2016-02-13)"},{"location":"changelog/#01-2016-01-31","text":"Initial release. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"0.1 (2016-01-31)"},{"location":"faq/","text":"FAQ \u00b6 Why do not use type annotations? \u00b6 It is possible to look for types of __init__ arguments instead of names. Obviously, code written in this style will look something like this: >>> from app.types import TypedInjector >>> from app.purchase import ( ... AbstractPaymentService , PaypalService , ... AbstractNotificationService , SMSService ... ) >>> class PurchaseService : ... ... def __init__ ( ... self , ... payments : AbstractPaymentService , ... notifications : AbstractNotificationService , ... ): ... self . payments = payments ... self . notifications = notifications >>> container = TypedInjector () >>> container . register ( SMSService ) >>> container . register ( PaypalService ) >>> container . build ( PurchaseService ) # doctest: +ELLIPSIS <__main__.PurchaseService object at 0x...> In our opinion, this makes code less declarative. It's hard to tell how dependencies will be resolved. At the same time, looking on container definition and a signature of the __init__ method can you easily say what arguments will be passed to the constructor? You can't. You will need to inspect all superclasses of each dependency registered in the container. With our Injector approach, you don't have this problem. You will find arguments right in the Injector subclass in one place. It's a global mutable variable. Container definition can be split into different files. This will make it harder to read. It's very similar to the service locator. Many architect people consider it an anti-pattern. It hard to define multiple dependencies of the same type. For example, your service needs two databases to work with. You need to define two different classes for types signatures and then define two different database classes. The same is necessary for these classes arguments. Both of them needs a port to run. How would you name it? PrimaryDatabasePort and SecondaryDatabasePort instead of int ? This leads to unnecessary boilerplate. Mixins considered harmful \u00b6 dependencies are compared with mixins often, since both solutions are ways to maximize code reuse. We already discussed this in the why chapter. But let's return to it again: Note Inheritance always breaks encapsulation. Mixin class depends on attributes set in other classes. Consider this code snippet: >>> class RetrieveModelMixin ( object ): ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data ) Where were get_object and get_serializer defined? We have no idea. We believe the code below is way better in the sense of understandability: >>> class RetrieveModel ( object ): ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def __init__ ( self , get_object , get_serializer ): ... self . get_object = get_object ... self . get_serializer = get_serializer ... ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data ) What to inject, and what not to \u00b6 It can be hard to draw the border between what should be injectable and what shouldn't be. Let's consider this typical example. >>> import requests >>> import dependencies >>> class UserGetter : ... ... def __init__ ( self , http ): ... self . http = http ... ... def __call__ ( self , user_id ): ... return self . http . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) . json () >>> class Users ( dependencies . Injector ): ... ... get = UserGetter ... http = requests >>> Users . get ( 1 ) {'id': 1, 'name': 'John', 'surname': 'Doe'} Should I write code like this? Will I ever decide to use something other than the excellent requests library? In our opinion these are not the correct questions to ask. By injecting a certain library you add a hard dependency on its interfaces to the whole system. Migration to other libraries in the future can be painful. Also, this adds another hard dependency to the whole system. Your code depends on the structure of third-party API response. This makes the situation even worse. Migration to other third-party services will be painful, as well. We believe that HTTP protocol itself is an implementation detail! We prefer to use dependency injection only on boundaries we control: >>> import dataclasses >>> import dependencies >>> import requests >>> class HomePage : ... ... def __init__ ( self , get_user ): ... self . get_user = get_user ... ... def show ( self , user_id ): ... user = self . get_user ( user_id = user_id ) >>> @dataclasses . dataclass ... class UserStruct : ... ... id : int ... name : str ... surname : str >>> def get_user ( user_id ): ... ... response = requests . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) ... return UserStruct ( ** response . json ()) >>> class Site ( dependencies . Injector ): ... ... home_page = HomePage ... get_user = get_user >>> Site . home_page . show ( 1 ) \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#why-do-not-use-type-annotations","text":"It is possible to look for types of __init__ arguments instead of names. Obviously, code written in this style will look something like this: >>> from app.types import TypedInjector >>> from app.purchase import ( ... AbstractPaymentService , PaypalService , ... AbstractNotificationService , SMSService ... ) >>> class PurchaseService : ... ... def __init__ ( ... self , ... payments : AbstractPaymentService , ... notifications : AbstractNotificationService , ... ): ... self . payments = payments ... self . notifications = notifications >>> container = TypedInjector () >>> container . register ( SMSService ) >>> container . register ( PaypalService ) >>> container . build ( PurchaseService ) # doctest: +ELLIPSIS <__main__.PurchaseService object at 0x...> In our opinion, this makes code less declarative. It's hard to tell how dependencies will be resolved. At the same time, looking on container definition and a signature of the __init__ method can you easily say what arguments will be passed to the constructor? You can't. You will need to inspect all superclasses of each dependency registered in the container. With our Injector approach, you don't have this problem. You will find arguments right in the Injector subclass in one place. It's a global mutable variable. Container definition can be split into different files. This will make it harder to read. It's very similar to the service locator. Many architect people consider it an anti-pattern. It hard to define multiple dependencies of the same type. For example, your service needs two databases to work with. You need to define two different classes for types signatures and then define two different database classes. The same is necessary for these classes arguments. Both of them needs a port to run. How would you name it? PrimaryDatabasePort and SecondaryDatabasePort instead of int ? This leads to unnecessary boilerplate.","title":"Why do not use type annotations?"},{"location":"faq/#mixins-considered-harmful","text":"dependencies are compared with mixins often, since both solutions are ways to maximize code reuse. We already discussed this in the why chapter. But let's return to it again: Note Inheritance always breaks encapsulation. Mixin class depends on attributes set in other classes. Consider this code snippet: >>> class RetrieveModelMixin ( object ): ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data ) Where were get_object and get_serializer defined? We have no idea. We believe the code below is way better in the sense of understandability: >>> class RetrieveModel ( object ): ... \"\"\" ... Retrieve a model instance. ... \"\"\" ... def __init__ ( self , get_object , get_serializer ): ... self . get_object = get_object ... self . get_serializer = get_serializer ... ... def retrieve ( self , request , * args , ** kwargs ): ... instance = self . get_object () ... serializer = self . get_serializer ( instance ) ... return Response ( serializer . data )","title":"Mixins considered harmful"},{"location":"faq/#what-to-inject-and-what-not-to","text":"It can be hard to draw the border between what should be injectable and what shouldn't be. Let's consider this typical example. >>> import requests >>> import dependencies >>> class UserGetter : ... ... def __init__ ( self , http ): ... self . http = http ... ... def __call__ ( self , user_id ): ... return self . http . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) . json () >>> class Users ( dependencies . Injector ): ... ... get = UserGetter ... http = requests >>> Users . get ( 1 ) {'id': 1, 'name': 'John', 'surname': 'Doe'} Should I write code like this? Will I ever decide to use something other than the excellent requests library? In our opinion these are not the correct questions to ask. By injecting a certain library you add a hard dependency on its interfaces to the whole system. Migration to other libraries in the future can be painful. Also, this adds another hard dependency to the whole system. Your code depends on the structure of third-party API response. This makes the situation even worse. Migration to other third-party services will be painful, as well. We believe that HTTP protocol itself is an implementation detail! We prefer to use dependency injection only on boundaries we control: >>> import dataclasses >>> import dependencies >>> import requests >>> class HomePage : ... ... def __init__ ( self , get_user ): ... self . get_user = get_user ... ... def show ( self , user_id ): ... user = self . get_user ( user_id = user_id ) >>> @dataclasses . dataclass ... class UserStruct : ... ... id : int ... name : str ... surname : str >>> def get_user ( user_id ): ... ... response = requests . get ( \"http://api.com/users/ %d /\" % ( user_id ,)) ... return UserStruct ( ** response . json ()) >>> class Site ( dependencies . Injector ): ... ... home_page = HomePage ... get_user = get_user >>> Site . home_page . show ( 1 ) \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"What to inject, and what not to"},{"location":"implementation/","text":"Internals \u00b6 There a lot of magic under the hood of this library. Metaclasses, dunder methods and inspect module all flying around. When you define a class inherited from Injector : Metaclass walks through all attributes defined in the class. If an attribute is a class , we use inspect to analyse its constructor and make note of the spec of its dependencies. At the end, it checks for circle links in the definition of the constructors, to protect you from infinite recursion. When you access an attribute of the class inherited from Injector : getattr defined in the class (with metaclass) looks for the attribute value. If the value is not a class, it is returned as is. If it is a class, the metaclass looks for its spec. In the loop, it tries to resolve each of constructor's arguments to match the spec, until all attributes are resolved. If a found attribute is a class, we call getattr again looking for its spec in the same loop without recursion. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Implementation"},{"location":"implementation/#internals","text":"There a lot of magic under the hood of this library. Metaclasses, dunder methods and inspect module all flying around. When you define a class inherited from Injector : Metaclass walks through all attributes defined in the class. If an attribute is a class , we use inspect to analyse its constructor and make note of the spec of its dependencies. At the end, it checks for circle links in the definition of the constructors, to protect you from infinite recursion. When you access an attribute of the class inherited from Injector : getattr defined in the class (with metaclass) looks for the attribute value. If the value is not a class, it is returned as is. If it is a class, the metaclass looks for its spec. In the loop, it tries to resolve each of constructor's arguments to match the spec, until all attributes are resolved. If a found attribute is a class, we call getattr again looking for its spec in the same loop without recursion. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Internals"},{"location":"installation/","text":"Installation \u00b6 The dependencies library is available on PyPI. To install it run: pip install -U dependencies \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Installation"},{"location":"installation/#installation","text":"The dependencies library is available on PyPI. To install it run: pip install -U dependencies \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Installation"},{"location":"overview/","text":"Overview \u00b6 dependencies library provides a nice DSL for specifying relations of your classes and make instantiation as simple as attribute access. >>> from dependencies import Injector >>> from app.robot import Robot , Servo , Amplifier , Controller , Settings >>> class Container ( Injector ): ... robot = Robot # Constructor of this class needs `servo`, `controller`, and `settings` arguments. ... servo = Servo # Constructor of this class needs `amplifier` argument. ... amplifier = Amplifier ... controller = Controller ... settings = Settings # Constructor of this class needs `environment` argument. ... environment = \"production\" >>> Container . robot . work () >>> # `---> This attribute access creates instances of `Controller`, >>> # `Amplifier`, `Settings`, `Servo`, and `Robot` classes >>> # in the proper order and calls each constructor with >>> # proper arguments. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Overview"},{"location":"overview/#overview","text":"dependencies library provides a nice DSL for specifying relations of your classes and make instantiation as simple as attribute access. >>> from dependencies import Injector >>> from app.robot import Robot , Servo , Amplifier , Controller , Settings >>> class Container ( Injector ): ... robot = Robot # Constructor of this class needs `servo`, `controller`, and `settings` arguments. ... servo = Servo # Constructor of this class needs `amplifier` argument. ... amplifier = Amplifier ... controller = Controller ... settings = Settings # Constructor of this class needs `environment` argument. ... environment = \"production\" >>> Container . robot . work () >>> # `---> This attribute access creates instances of `Controller`, >>> # `Amplifier`, `Settings`, `Servo`, and `Robot` classes >>> # in the proper order and calls each constructor with >>> # proper arguments. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Overview"},{"location":"usage/","text":"Usage \u00b6 Preparations \u00b6 Before we start to inject dependencies, let's define code which needs these dependencies. Also, let's add some behavior to your robot. >>> class Robot : ... def __init__ ( self , servo , controller , settings ): ... self . servo = servo ... self . controller = controller ... self . settings = settings ... ... def run ( self ): ... while True : ... events = self . accept_events () ... if not events : ... break ... self . process ( events ) ... ... def accept_events ( self ): ... # We can inject methods. ... return self . controller () ... ... def process ( self , events ): ... # We can inject dictionaries. ... max_point = self . settings [ 'max_point' ] ... for event in events : ... if event . x > max_point : ... # We can inject objects. ... self . servo . reverse ( 'x' ) ... if event . y > max_point : ... self . servo . reverse ( 'y' ) We use constructor-based dependency injection here: we define necessary arguments and store them explicitly, for the sake of readability. This will help us to understand the execution path of your system. Attributes sourced from nowhere in your code aren't fun. Believe me. Now, it's time to make this work in the real world. >>> class MechanicalMotor : ... def reverse ( self , coordinate ): ... # Hardware work goes here. ... pass >>> def read_sensor (): ... # Another hardware work goes here. ... return [] >>> production = { 'max_point' : 0.01 } So, we are close to scream \"It's alive!\" and, if we're lucky enough, run out of the building. >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = MechanicalMotor ... controller = read_sensor ... settings = production >>> robot = Container . robot # Robots' constructor called here. >>> robot . run () Congratulations! We've built our robot with dependency injection. Injection rules \u00b6 Container above is a dependency scope, and dependencies are defined as its attributes. When you access one of those attributes, the following happens: If attribute value is a class , it will be instantiated. To make that possible, the library will inspect its constructor's argument list and search current dependency scope for dependencies with the same name. If attribute value is a class but attribute name ends with _class - then it will be returned as is. (For example, Container.foo_class will return the class stored in it, not its instance). Anything else is returned as is. If, during dependency search, we encounter another class - it will be instantiated along these rules, as well. The process is recursive. Here is a demonstration of rules above. >>> class Foo : ... def __init__ ( self , one , two ): ... self . one = one ... self . two = two >>> class Bar : ... pass >>> class Baz : ... def __init__ ( self , x ): ... self . x = x >>> from dependencies import Injector >>> class Scope ( Injector ): ... foo = Foo ... one = Bar ... two = Baz ... x = 1 >>> Scope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> >>> Scope . foo . one # doctest: +ELLIPSIS <__main__.Bar object at 0x...> >>> Scope . foo . two # doctest: +ELLIPSIS <__main__.Baz object at 0x...> >>> Scope . foo . two . x 1 Let's roll down what is happening here: Foo class requires an argument named two ; In dependency scope, that argument resolves to Baz class; Which is a class - oh boy, we need to instantiate it as well; But its constructor requires an argument named x ; Which resolves to 1 in the dependency scope, so we do not need to go any further. Having found that out, we effectively construct, execute, and return Foo(two=Baz(x=1)) . Calculation rules \u00b6 Each dependency evaluates exactly once during injection process. If during dependency injection different classes have constructor argument with the same name, the corresponding dependency will be instantiated once and these two constructors will receive the same object. But this object only lives during one injection process; another attribute access means a new object. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar , baz ): ... self . bar = bar ... self . baz = baz ... ... def check ( self ): ... return self . bar . x is self . baz . x ... ... class Bar : ... ... def __init__ ( self , x ): ... self . x = x ... ... class Baz : ... ... def __init__ ( self , x ): ... self . x = x ... ... class X : ... pass ... ... # Names. ... foo , bar , baz , x = Foo , Bar , Baz , X >>> Container . foo . check () True >>> Container . bar . x is Container . bar . x False Nested Injectors \u00b6 It is possible to inject Injector itself. Injector subclasses are provided as is, and calculate their attributes on first use. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar ): ... self . bar = bar ... ... def __call__ ( self ): ... return self . bar . baz () ... ... class Bar ( Injector ): ... ... class Baz : ... ... def __init__ ( self , func ): ... self . func = func ... ... def __call__ ( self ): ... return self . func () ... ... def func (): ... return 1 ... ... # Names. ... baz = Baz ... ... # Names. ... foo , bar = Foo , Bar >>> Container . foo () 1 >>> Container . foo . bar <class '_dependencies.injector.Bar'> >>> Container . foo . bar . baz # doctest: +ELLIPSIS <__main__.Container.Bar.Baz object at 0x...> >>> Container . foo . bar . baz . func # doctest: +ELLIPSIS <function Container.Bar.func at 0x...> >>> Container . foo . bar . baz . func () 1 Scope extension \u00b6 You can define a dependency scope partially and then extend it; only in injection moment, meaning at the time of attribute access, you are required to have the complete scope. There are two ways to extend dependency scopes: inheritance let notation Inheritance \u00b6 You can add additional dependencies or redefine existing ones in a scope subclass: >>> class Foo : ... pass >>> class Scope ( Injector ): ... foo = Foo >>> class ChildScope ( Scope ): ... bar = Bar >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> Multiple inheritance is allowed as well. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> class ChildScope ( Scope1 , Scope2 ): ... pass >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> We also provide and notation for in-place Injector composition. Example below is full equivalent to the previous one, but without intermediate class needed. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> ( Scope1 & Scope2 ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> let notation \u00b6 You can temporary redefine a dependency for only one case. This is extremely useful for tests. Inject an assertion instead of one or more dependencies, and you will be able to test your system in all possible cases. It is, for example, possible to simulate database integrity error on concurrent access. >>> class Scope ( Injector ): ... foo = Foo ... bar = Bar >>> Scope . let ( bar = Baz ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> It is possible to build dependency scopes directly from dictionaries using let notation. >>> settings = { 'host' : 'localhost' , 'port' : 1234 } >>> Scope = Injector . let ( foo = Foo , bar = Bar , ** settings ) hasattr alternative \u00b6 hasattr works by attribute access, so it triggers dependency injection. If this is unnecessary side effect, dependencies provides alternative way. >>> class Container ( Injector ): ... foo = 1 >>> 'foo' in Container True \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#preparations","text":"Before we start to inject dependencies, let's define code which needs these dependencies. Also, let's add some behavior to your robot. >>> class Robot : ... def __init__ ( self , servo , controller , settings ): ... self . servo = servo ... self . controller = controller ... self . settings = settings ... ... def run ( self ): ... while True : ... events = self . accept_events () ... if not events : ... break ... self . process ( events ) ... ... def accept_events ( self ): ... # We can inject methods. ... return self . controller () ... ... def process ( self , events ): ... # We can inject dictionaries. ... max_point = self . settings [ 'max_point' ] ... for event in events : ... if event . x > max_point : ... # We can inject objects. ... self . servo . reverse ( 'x' ) ... if event . y > max_point : ... self . servo . reverse ( 'y' ) We use constructor-based dependency injection here: we define necessary arguments and store them explicitly, for the sake of readability. This will help us to understand the execution path of your system. Attributes sourced from nowhere in your code aren't fun. Believe me. Now, it's time to make this work in the real world. >>> class MechanicalMotor : ... def reverse ( self , coordinate ): ... # Hardware work goes here. ... pass >>> def read_sensor (): ... # Another hardware work goes here. ... return [] >>> production = { 'max_point' : 0.01 } So, we are close to scream \"It's alive!\" and, if we're lucky enough, run out of the building. >>> from dependencies import Injector >>> class Container ( Injector ): ... robot = Robot ... servo = MechanicalMotor ... controller = read_sensor ... settings = production >>> robot = Container . robot # Robots' constructor called here. >>> robot . run () Congratulations! We've built our robot with dependency injection.","title":"Preparations"},{"location":"usage/#injection-rules","text":"Container above is a dependency scope, and dependencies are defined as its attributes. When you access one of those attributes, the following happens: If attribute value is a class , it will be instantiated. To make that possible, the library will inspect its constructor's argument list and search current dependency scope for dependencies with the same name. If attribute value is a class but attribute name ends with _class - then it will be returned as is. (For example, Container.foo_class will return the class stored in it, not its instance). Anything else is returned as is. If, during dependency search, we encounter another class - it will be instantiated along these rules, as well. The process is recursive. Here is a demonstration of rules above. >>> class Foo : ... def __init__ ( self , one , two ): ... self . one = one ... self . two = two >>> class Bar : ... pass >>> class Baz : ... def __init__ ( self , x ): ... self . x = x >>> from dependencies import Injector >>> class Scope ( Injector ): ... foo = Foo ... one = Bar ... two = Baz ... x = 1 >>> Scope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> >>> Scope . foo . one # doctest: +ELLIPSIS <__main__.Bar object at 0x...> >>> Scope . foo . two # doctest: +ELLIPSIS <__main__.Baz object at 0x...> >>> Scope . foo . two . x 1 Let's roll down what is happening here: Foo class requires an argument named two ; In dependency scope, that argument resolves to Baz class; Which is a class - oh boy, we need to instantiate it as well; But its constructor requires an argument named x ; Which resolves to 1 in the dependency scope, so we do not need to go any further. Having found that out, we effectively construct, execute, and return Foo(two=Baz(x=1)) .","title":"Injection rules"},{"location":"usage/#calculation-rules","text":"Each dependency evaluates exactly once during injection process. If during dependency injection different classes have constructor argument with the same name, the corresponding dependency will be instantiated once and these two constructors will receive the same object. But this object only lives during one injection process; another attribute access means a new object. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar , baz ): ... self . bar = bar ... self . baz = baz ... ... def check ( self ): ... return self . bar . x is self . baz . x ... ... class Bar : ... ... def __init__ ( self , x ): ... self . x = x ... ... class Baz : ... ... def __init__ ( self , x ): ... self . x = x ... ... class X : ... pass ... ... # Names. ... foo , bar , baz , x = Foo , Bar , Baz , X >>> Container . foo . check () True >>> Container . bar . x is Container . bar . x False","title":"Calculation rules"},{"location":"usage/#nested-injectors","text":"It is possible to inject Injector itself. Injector subclasses are provided as is, and calculate their attributes on first use. >>> from dependencies import Injector >>> class Container ( Injector ): ... ... class Foo : ... ... def __init__ ( self , bar ): ... self . bar = bar ... ... def __call__ ( self ): ... return self . bar . baz () ... ... class Bar ( Injector ): ... ... class Baz : ... ... def __init__ ( self , func ): ... self . func = func ... ... def __call__ ( self ): ... return self . func () ... ... def func (): ... return 1 ... ... # Names. ... baz = Baz ... ... # Names. ... foo , bar = Foo , Bar >>> Container . foo () 1 >>> Container . foo . bar <class '_dependencies.injector.Bar'> >>> Container . foo . bar . baz # doctest: +ELLIPSIS <__main__.Container.Bar.Baz object at 0x...> >>> Container . foo . bar . baz . func # doctest: +ELLIPSIS <function Container.Bar.func at 0x...> >>> Container . foo . bar . baz . func () 1","title":"Nested Injectors"},{"location":"usage/#scope-extension","text":"You can define a dependency scope partially and then extend it; only in injection moment, meaning at the time of attribute access, you are required to have the complete scope. There are two ways to extend dependency scopes: inheritance let notation","title":"Scope extension"},{"location":"usage/#inheritance","text":"You can add additional dependencies or redefine existing ones in a scope subclass: >>> class Foo : ... pass >>> class Scope ( Injector ): ... foo = Foo >>> class ChildScope ( Scope ): ... bar = Bar >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> Multiple inheritance is allowed as well. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> class ChildScope ( Scope1 , Scope2 ): ... pass >>> ChildScope . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> We also provide and notation for in-place Injector composition. Example below is full equivalent to the previous one, but without intermediate class needed. >>> class Scope1 ( Injector ): ... foo = Foo >>> class Scope2 ( Injector ): ... bar = Bar >>> ( Scope1 & Scope2 ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...>","title":"Inheritance"},{"location":"usage/#let-notation","text":"You can temporary redefine a dependency for only one case. This is extremely useful for tests. Inject an assertion instead of one or more dependencies, and you will be able to test your system in all possible cases. It is, for example, possible to simulate database integrity error on concurrent access. >>> class Scope ( Injector ): ... foo = Foo ... bar = Bar >>> Scope . let ( bar = Baz ) . foo # doctest: +ELLIPSIS <__main__.Foo object at 0x...> It is possible to build dependency scopes directly from dictionaries using let notation. >>> settings = { 'host' : 'localhost' , 'port' : 1234 } >>> Scope = Injector . let ( foo = Foo , bar = Bar , ** settings )","title":"let notation"},{"location":"usage/#hasattr-alternative","text":"hasattr works by attribute access, so it triggers dependency injection. If this is unnecessary side effect, dependencies provides alternative way. >>> class Container ( Injector ): ... foo = 1 >>> 'foo' in Container True \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"hasattr alternative"},{"location":"why/","text":"Why not... \u00b6 Here we will try to collect pros and cons of different approaches to make your code extendable and reusable. Let's imagine we have an order processing system. We want to implement order purchase feature. There is a lot of functionality to be built: We should change our data, send a request to the payment processing system, and we should send notification to the user. Simple functions \u00b6 Let's do it with simple functions. >>> def purchase ( user , product , shipment_details ): ... ... order = create_order ( user , product ) ... final_price = calculate_price ( order , shipment_details ) ... payment_details = request_payment ( user , shipment_details ) ... notify_user ( user , payment_details ) >>> def notify_user ( user , payment_details ): ... ... log_notification ( user , payment_details ) ... subject = get_notification_subject ( payment_details ) ... message = get_notification_text ( user , payment_details ) ... send_notification ( user , subject , message ) >>> def send_notification ( user , subject , message ): ... ... email = get_user_email ( user ) ... send_email ( email , subject , message ) It's a readable and straightforward solution. What can possibly go wrong? Problem is that this code is difficult to change and extend. For example, you need to add SMS and push notifications in addition to plain text emails. To do that, you'll have to add a handful of different conditions to this simple default path. Push notification to the mobile app should be written in Markdown format, SMS requires plain text, and email needs HTML in addition to plain text. Users should be able to choose their preferred notification method. How can we change the code above to match new requirements? We have problems on all three layers of the code: purchase , notify_user and send_notification functions have to be changed. Add conditions to all parameters to all layers of the code. This will end up with messy code which is even harder to extend. No one wants purchase function to have 12 arguments. No one wants to wonder why send_email function accepts phone number. No one wants to read 7 if statements in the notify_user function when they are about to add eighth condition. Add context variable instead of another argument. This little ctx argument instead of email address, phone number, product price and shipment destination will save us a lot of typing between function calls. But we still have bunch of if statements. Copy-paste this module and re-implement each feature separately. Each feature will be readable and simple on it's own, but you will regret this decision when usage of request_payment or calculate_price changes. But we still have the same problem. We can't substitute implementation details of low level code without changing high level policies. Let's try... Inheritance \u00b6 Let's rewrite our functions into a class which we can subclass for different purposes. >>> class Order : ... ... def __init__ ( self , user , product , shipment_details ): ... ... self . user = user ... self . product = product ... self . shipment_details = shipment_details ... self . final_price = None # Set by `calculate_price`. ... self . payment_details = None # Set by `request_payment`. ... self . subject = None # Set by `get_notification_subject`. ... self . message = None # Set by `get_notification_text`. ... self . email = None # Set by `get_user_email`. ... ... def purchase ( self ): ... ... self . create_order () ... self . calculate_price () ... self . request_payment () ... self . notify_user () ... ... def notify_user ( self ): ... ... self . log_notification () ... self . get_notification_subject () ... self . get_notification_text () ... self . send_notification () ... ... def send_notification ( self ): ... ... self . get_user_email () ... self . send_email () At first glance, this class is a better solution than before. Indeed, this code has several advantages. At first glance high level methods even more readable. There are no nosy arguments or variables. Only nice named methods. Simple code reuse. With inheritance, we can override any method on any layer of abstraction in the system. We can add any number of methods or attributes is the child classes. Looks like it is a very reasonable approach. But this code hides quite a few problems underneath the false premise of understandability and cleanness. God object. One class contains methods related to every single layer of abstraction in the system. It's hard to manage two hundred methods in the same class: one will process HTTP request, another one will send email, and yet another one will write to the database. It's hard to figure out what exactly this class does. Bad state management. During the life time of a class instance different methods change state of the class. When you read short method somewhere inside email sender logic, you have no idea from where attribute values came from and when exactly they were set. Hello print statements to understand the code... Let's reduce amount of logic in the class (responsibility of the class). Let's try... Mixins \u00b6 We can split our God object into multiple classes and join it together later using multiple inheritance. >>> class OrderProcessingMixin : ... ... def create_order ( self ): ... ... pass >>> class PriceCalculationMixin : ... ... def calculate_price ( self ): ... ... pass >>> class NotificationMixin : ... ... def get_notification_text ( self ): ... ... self . notification_text = self . notification_text_template % ( ... self . user , ... self . payment_details , ... ) >>> class Order ( OrderProcessingMixin , ... PriceCalculationMixin , ... NotificationMixin ): ... ... def before_calculate ( self ): ... ... self . create_order () ... ... def after_commit ( self ): ... ... self . send_email () Someone might say this is an improvement over one huge class. All methods grouped in classes with the same responsibility. Better code reuse. We can use the same notification mechanism in different classes with just one line of code. But there are a lot of problems too. During a debugging session, In the get_notification_text you have no idea who set up payment_details . In the Order class itself you see a bunch of low level methods which are deep implementation details. What public method should I call? When notification will be sent, exactly? This code is much harder to understand than it should be. Even if it reusable, this complexity in too large for my head. Let's try... Composition \u00b6 Composition is a powerful pattern of organizing code with proper code boundaries and clear dependency relationship. >>> class OrderProcessor : ... ... def create ( self , user , product ): ... ... pass >>> class PriceCalculator : ... ... def calculate ( self , product , shipment_details ): ... ... pass >>> class PaymentProcessor : ... ... def request ( self , user , shipment_details ): ... ... pass >>> class Notification : ... ... def __init__ ( self , logger ): ... ... self . logger = logger ... ... def notify ( self , user , payment_details ): ... ... self . logger . record ( user , payment_details ) ... subject = self . get_notification_subject ( payment_details ) ... message = self . get_notification_text ( user , payment_details ) ... self . send_notification ( user , subject , message ) ... ... def get_notification_subject ( self , payment_details ): ... ... pass ... ... def get_notification_text ( self , user , payment_details ): ... ... pass ... ... def send_notification ( self , user , subject , message ): ... ... pass >>> class Order : ... ... def __init__ ( self , order_processor , price_calculator , ... payment_processor , notification ): ... ... self . order_processor = order_processor ... self . price_calculator = price_calculator ... self . payment_processor = payment_processor ... self . notification = notification ... ... def purchase ( self , user , product , shipment_details ): ... ... self . order_processor . create ( user , product ) ... final_price = self . price_calculator . calculate ( product , shipment_details ) ... payment_details = self . payment_processor . request ( user , shipment_details ) ... self . notification . notify ( user , payment_details ) >>> from app.shop import Logger , User , Product , ShipmentDetails >>> Order ( ... OrderProcessor (), ... PriceCalculator (), ... PaymentProcessor (), ... Notification ( Logger ()), ... ) . purchase ( User (), Product (), ShipmentDetails ()) This code has a number of really good characteristics. It's clear where things were defined. If you try to understand what's wrong with your system, you can just use traceback. No nasty code execution paths. Your system becomes really configurable. You can inject pretty much any implementation without changing high-level code. But there one unfortunate consequence of this style There is too much boilerplate on the initiation stage. Let's try... Dependencies \u00b6 Here's where dependencies library comes in. >>> from dependencies import Injector >>> class OrderContainer ( Injector ): ... ... order = Order ... order_processor = OrderProcessor ... price_calculator = PriceCalculator ... payment_processor = PaymentProcessor ... notification = Notification ... logger = Logger >>> OrderContainer . order . purchase ( User (), Product (), ShipmentDetails ()) It helps you to reduce the boilerplate of the initiation stage. It doesn't require you to change your code. You still can instantiate your classes directly, if you don't like this library. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Why"},{"location":"why/#why-not","text":"Here we will try to collect pros and cons of different approaches to make your code extendable and reusable. Let's imagine we have an order processing system. We want to implement order purchase feature. There is a lot of functionality to be built: We should change our data, send a request to the payment processing system, and we should send notification to the user.","title":"Why not..."},{"location":"why/#simple-functions","text":"Let's do it with simple functions. >>> def purchase ( user , product , shipment_details ): ... ... order = create_order ( user , product ) ... final_price = calculate_price ( order , shipment_details ) ... payment_details = request_payment ( user , shipment_details ) ... notify_user ( user , payment_details ) >>> def notify_user ( user , payment_details ): ... ... log_notification ( user , payment_details ) ... subject = get_notification_subject ( payment_details ) ... message = get_notification_text ( user , payment_details ) ... send_notification ( user , subject , message ) >>> def send_notification ( user , subject , message ): ... ... email = get_user_email ( user ) ... send_email ( email , subject , message ) It's a readable and straightforward solution. What can possibly go wrong? Problem is that this code is difficult to change and extend. For example, you need to add SMS and push notifications in addition to plain text emails. To do that, you'll have to add a handful of different conditions to this simple default path. Push notification to the mobile app should be written in Markdown format, SMS requires plain text, and email needs HTML in addition to plain text. Users should be able to choose their preferred notification method. How can we change the code above to match new requirements? We have problems on all three layers of the code: purchase , notify_user and send_notification functions have to be changed. Add conditions to all parameters to all layers of the code. This will end up with messy code which is even harder to extend. No one wants purchase function to have 12 arguments. No one wants to wonder why send_email function accepts phone number. No one wants to read 7 if statements in the notify_user function when they are about to add eighth condition. Add context variable instead of another argument. This little ctx argument instead of email address, phone number, product price and shipment destination will save us a lot of typing between function calls. But we still have bunch of if statements. Copy-paste this module and re-implement each feature separately. Each feature will be readable and simple on it's own, but you will regret this decision when usage of request_payment or calculate_price changes. But we still have the same problem. We can't substitute implementation details of low level code without changing high level policies. Let's try...","title":"Simple functions"},{"location":"why/#inheritance","text":"Let's rewrite our functions into a class which we can subclass for different purposes. >>> class Order : ... ... def __init__ ( self , user , product , shipment_details ): ... ... self . user = user ... self . product = product ... self . shipment_details = shipment_details ... self . final_price = None # Set by `calculate_price`. ... self . payment_details = None # Set by `request_payment`. ... self . subject = None # Set by `get_notification_subject`. ... self . message = None # Set by `get_notification_text`. ... self . email = None # Set by `get_user_email`. ... ... def purchase ( self ): ... ... self . create_order () ... self . calculate_price () ... self . request_payment () ... self . notify_user () ... ... def notify_user ( self ): ... ... self . log_notification () ... self . get_notification_subject () ... self . get_notification_text () ... self . send_notification () ... ... def send_notification ( self ): ... ... self . get_user_email () ... self . send_email () At first glance, this class is a better solution than before. Indeed, this code has several advantages. At first glance high level methods even more readable. There are no nosy arguments or variables. Only nice named methods. Simple code reuse. With inheritance, we can override any method on any layer of abstraction in the system. We can add any number of methods or attributes is the child classes. Looks like it is a very reasonable approach. But this code hides quite a few problems underneath the false premise of understandability and cleanness. God object. One class contains methods related to every single layer of abstraction in the system. It's hard to manage two hundred methods in the same class: one will process HTTP request, another one will send email, and yet another one will write to the database. It's hard to figure out what exactly this class does. Bad state management. During the life time of a class instance different methods change state of the class. When you read short method somewhere inside email sender logic, you have no idea from where attribute values came from and when exactly they were set. Hello print statements to understand the code... Let's reduce amount of logic in the class (responsibility of the class). Let's try...","title":"Inheritance"},{"location":"why/#mixins","text":"We can split our God object into multiple classes and join it together later using multiple inheritance. >>> class OrderProcessingMixin : ... ... def create_order ( self ): ... ... pass >>> class PriceCalculationMixin : ... ... def calculate_price ( self ): ... ... pass >>> class NotificationMixin : ... ... def get_notification_text ( self ): ... ... self . notification_text = self . notification_text_template % ( ... self . user , ... self . payment_details , ... ) >>> class Order ( OrderProcessingMixin , ... PriceCalculationMixin , ... NotificationMixin ): ... ... def before_calculate ( self ): ... ... self . create_order () ... ... def after_commit ( self ): ... ... self . send_email () Someone might say this is an improvement over one huge class. All methods grouped in classes with the same responsibility. Better code reuse. We can use the same notification mechanism in different classes with just one line of code. But there are a lot of problems too. During a debugging session, In the get_notification_text you have no idea who set up payment_details . In the Order class itself you see a bunch of low level methods which are deep implementation details. What public method should I call? When notification will be sent, exactly? This code is much harder to understand than it should be. Even if it reusable, this complexity in too large for my head. Let's try...","title":"Mixins"},{"location":"why/#composition","text":"Composition is a powerful pattern of organizing code with proper code boundaries and clear dependency relationship. >>> class OrderProcessor : ... ... def create ( self , user , product ): ... ... pass >>> class PriceCalculator : ... ... def calculate ( self , product , shipment_details ): ... ... pass >>> class PaymentProcessor : ... ... def request ( self , user , shipment_details ): ... ... pass >>> class Notification : ... ... def __init__ ( self , logger ): ... ... self . logger = logger ... ... def notify ( self , user , payment_details ): ... ... self . logger . record ( user , payment_details ) ... subject = self . get_notification_subject ( payment_details ) ... message = self . get_notification_text ( user , payment_details ) ... self . send_notification ( user , subject , message ) ... ... def get_notification_subject ( self , payment_details ): ... ... pass ... ... def get_notification_text ( self , user , payment_details ): ... ... pass ... ... def send_notification ( self , user , subject , message ): ... ... pass >>> class Order : ... ... def __init__ ( self , order_processor , price_calculator , ... payment_processor , notification ): ... ... self . order_processor = order_processor ... self . price_calculator = price_calculator ... self . payment_processor = payment_processor ... self . notification = notification ... ... def purchase ( self , user , product , shipment_details ): ... ... self . order_processor . create ( user , product ) ... final_price = self . price_calculator . calculate ( product , shipment_details ) ... payment_details = self . payment_processor . request ( user , shipment_details ) ... self . notification . notify ( user , payment_details ) >>> from app.shop import Logger , User , Product , ShipmentDetails >>> Order ( ... OrderProcessor (), ... PriceCalculator (), ... PaymentProcessor (), ... Notification ( Logger ()), ... ) . purchase ( User (), Product (), ShipmentDetails ()) This code has a number of really good characteristics. It's clear where things were defined. If you try to understand what's wrong with your system, you can just use traceback. No nasty code execution paths. Your system becomes really configurable. You can inject pretty much any implementation without changing high-level code. But there one unfortunate consequence of this style There is too much boilerplate on the initiation stage. Let's try...","title":"Composition"},{"location":"why/#dependencies","text":"Here's where dependencies library comes in. >>> from dependencies import Injector >>> class OrderContainer ( Injector ): ... ... order = Order ... order_processor = OrderProcessor ... price_calculator = PriceCalculator ... payment_processor = PaymentProcessor ... notification = Notification ... logger = Logger >>> OrderContainer . order . purchase ( User (), Product (), ShipmentDetails ()) It helps you to reduce the boilerplate of the initiation stage. It doesn't require you to change your code. You still can instantiate your classes directly, if you don't like this library. \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Dependencies"},{"location":"proxies/operation/","text":"operation proxy \u00b6 Operation is a way to define injectable functions easily. This functions can only call other dependencies and take no additional value arguments. >>> from dependencies import Injector , operation Call \u00b6 Dependencies injected based on the arguments names. >>> class Container ( Injector ): ... foo = 1 ... bar = 2 ... baz = 3 ... ... @operation ... def func ( foo , bar , baz ): ... return foo + bar + baz >>> Container . func () == 6 True If you want to pass additional value parameter to the function, add it to the injector with the let notation. >>> class Foo : ... def do ( self , arg ): ... return arg + 3 >>> class Bar : ... def do ( self , arg ): ... return arg + 2 >>> class Container ( Injector ): ... foo = Foo ... bar = Bar ... ... @operation ... def func ( foo , bar , arg ): ... return foo . do ( bar . do ( arg )) >>> Container . let ( arg = 1 ) . func () 6 \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Operation"},{"location":"proxies/operation/#operation-proxy","text":"Operation is a way to define injectable functions easily. This functions can only call other dependencies and take no additional value arguments. >>> from dependencies import Injector , operation","title":"operation proxy"},{"location":"proxies/operation/#call","text":"Dependencies injected based on the arguments names. >>> class Container ( Injector ): ... foo = 1 ... bar = 2 ... baz = 3 ... ... @operation ... def func ( foo , bar , baz ): ... return foo + bar + baz >>> Container . func () == 6 True If you want to pass additional value parameter to the function, add it to the injector with the let notation. >>> class Foo : ... def do ( self , arg ): ... return arg + 3 >>> class Bar : ... def do ( self , arg ): ... return arg + 2 >>> class Container ( Injector ): ... foo = Foo ... bar = Bar ... ... @operation ... def func ( foo , bar , arg ): ... return foo . do ( bar . do ( arg )) >>> Container . let ( arg = 1 ) . func () 6 \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Call"},{"location":"proxies/package/","text":"Package proxy \u00b6 Package object is a way to define injector scope with dependencies defined in other places (like modules and packages). You can point package object to the module, a variable defined in the module, a function defined in the module, a class defined in the module, any attribute of the class which was defined in this module. >>> from dependencies import Injector , Package Attributes \u00b6 A usual use case for the Package object is to replace havy import statements with attribute access. If you have complex project structure, you will see a lot of code like this in your injectors. >>> from app.repositories import create_user >>> # A lot of import statements here... >>> class Container ( Injector ): ... persist_user = create_user ... # A lot of assignment statements here... To save some typing I tend to write this code like this >>> class Container ( Injector ): ... from app.repositories import create_user as persist_user ... # A lot of import statements here... Package can help to deal with this inconsistency >>> app = Package ( \"app\" ) >>> class Container ( Injector ): ... persist_user = app . repositories . create_user ... # A lot of assignment statements here... If a lot of dependencies defined in the repositories module, you can set Package source to the repositories module itself. >>> repositories = Package ( \"app.repositories\" ) >>> class Container ( Injector ): ... persist_user = repositories . create_user ... # A lot of assignment statements here... Classes \u00b6 If an attribute of the Package object point to the attribute of the class defined in some module, this class will be instantiated before attribute access is actually happen. You can inject bound methods with exactly one line. # app/calc.py >>> class Calc : ... ... def __init__ ( self , a , b ): ... self . a = a ... self . b = b ... ... def do ( self ): ... return self . a + self . b # app/base.py >>> calc = Package ( \"app.calc\" ) >>> class Container ( Injector ): ... foo = calc . Calc . do ... a = 1 ... b = 2 >>> assert Container . foo () == 3 The injector definition above is equivalent to the longuer version: >>> from dependencies import this >>> from app.calc import Calc >>> class Container ( Injector ): ... foo = this . tmp . do ... tmp = Calc ... a = 1 ... b = 2 >>> assert Container . foo () == 3 \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Package"},{"location":"proxies/package/#package-proxy","text":"Package object is a way to define injector scope with dependencies defined in other places (like modules and packages). You can point package object to the module, a variable defined in the module, a function defined in the module, a class defined in the module, any attribute of the class which was defined in this module. >>> from dependencies import Injector , Package","title":"Package proxy"},{"location":"proxies/package/#attributes","text":"A usual use case for the Package object is to replace havy import statements with attribute access. If you have complex project structure, you will see a lot of code like this in your injectors. >>> from app.repositories import create_user >>> # A lot of import statements here... >>> class Container ( Injector ): ... persist_user = create_user ... # A lot of assignment statements here... To save some typing I tend to write this code like this >>> class Container ( Injector ): ... from app.repositories import create_user as persist_user ... # A lot of import statements here... Package can help to deal with this inconsistency >>> app = Package ( \"app\" ) >>> class Container ( Injector ): ... persist_user = app . repositories . create_user ... # A lot of assignment statements here... If a lot of dependencies defined in the repositories module, you can set Package source to the repositories module itself. >>> repositories = Package ( \"app.repositories\" ) >>> class Container ( Injector ): ... persist_user = repositories . create_user ... # A lot of assignment statements here...","title":"Attributes"},{"location":"proxies/package/#classes","text":"If an attribute of the Package object point to the attribute of the class defined in some module, this class will be instantiated before attribute access is actually happen. You can inject bound methods with exactly one line. # app/calc.py >>> class Calc : ... ... def __init__ ( self , a , b ): ... self . a = a ... self . b = b ... ... def do ( self ): ... return self . a + self . b # app/base.py >>> calc = Package ( \"app.calc\" ) >>> class Container ( Injector ): ... foo = calc . Calc . do ... a = 1 ... b = 2 >>> assert Container . foo () == 3 The injector definition above is equivalent to the longuer version: >>> from dependencies import this >>> from app.calc import Calc >>> class Container ( Injector ): ... foo = this . tmp . do ... tmp = Calc ... a = 1 ... b = 2 >>> assert Container . foo () == 3 \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Classes"},{"location":"proxies/this/","text":"this proxy \u00b6 this is a declarative way to access attributes and items of other dependencies defined in the Injector subclasses. The Link is basically a pointer or an alias to another dependency in the same Injector , in nested Injector or in parent Injector . >>> from dependencies import Injector , this Simple links \u00b6 For example, you can create simple aliases. >>> class Container ( Injector ): ... foo = 1 ... bar = this . foo >>> Container . bar 1 You can use item access on dependencies defined in Injector subclass. >>> class Container ( Injector ): ... foo = { 'a' : 1 } ... bar = this . foo [ 'a' ] >>> Container . bar 1 Tuple, list, set and everything that supports iterable protocol are also supported. You can use this links as usual in the constructor arguments. >>> class Foo : ... def __init__ ( self , bar ): ... self . bar = bar >>> class Container ( Injector ): ... foo = Foo ... bar = this . baz ... baz = 1 >>> Container . foo . bar 1 Also, you can see, that you can define proxy a before the actual dependency it pointing to. You can point a link to the instance method. The actual instance will be built before resolving method access. This is a useful technique to hide whole class with its own state behind a single callable interface. >>> class Foo : ... def method ( self , arg ): ... print ( self ) ... print ( arg ) >>> class Container ( Injector ): ... foo = Foo ... bar = this . foo . method >>> Container . bar ( 1 ) # doctest: +ELLIPSIS <__main__.Foo object at 0x...> 1 You can see that method has access to the Foo instance. So it can call other methods of Foo . You can define dependencies of the Foo class in it constructor as usual. Nested and parent injector access \u00b6 Links created with this objects can access attributes defined in the nested injector. >>> class Container ( Injector ): ... foo = this . Bar . baz . __add__ ... class Bar ( Injector ): ... baz = 1 >>> Container . foo ( 2 ) 3 Nested Injector subclasses can access attributes of the parent Injector . Use left shift operator to specify the number of levels to go upper scope. >>> class Container ( Injector ): ... foo = 1 ... class Bar ( Injector ): ... baz = ( this << 1 ) . foo . __add__ >>> Container . Bar . baz ( 2 ) 3 Full example \u00b6 Let's define an application with all settings stored in the dictionary. In production, you can substitute this dictionary with Consul or ZooKeeper client and the rest of the application will be left untouched. >>> class Database : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Cache : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Application : ... def __init__ ( self , db , cache ): ... self . db = db ... self . cache = cache >>> class Container ( Injector ): ... app = Application ... db = this . DB . database ... cache = this . InMemory . cache ... ... class DB ( Injector ): ... database = Database ... host = ( this << 1 ) . settings [ 'database' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'database' ][ 'port' ] ... ... class InMemory ( Injector ): ... cache = Cache ... host = ( this << 1 ) . settings [ 'cache' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'cache' ][ 'port' ] ... ... settings = { ... 'database' : { ... 'host' : 'localhost' , ... 'port' : 5432 , ... }, ... 'cache' : { ... 'host' : 'localhost' , ... 'port' : 6782 , ... }, ... } >>> Container . app # doctest: +ELLIPSIS <__main__.Application object at 0x...> >>> Container . app . db # doctest: +ELLIPSIS <__main__.Database object at 0x...> >>> Container . app . db . port 5432 >>> Container . app . cache # doctest: +ELLIPSIS <__main__.Cache object at 0x...> >>> Container . app . cache . port 6782 \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"This"},{"location":"proxies/this/#this-proxy","text":"this is a declarative way to access attributes and items of other dependencies defined in the Injector subclasses. The Link is basically a pointer or an alias to another dependency in the same Injector , in nested Injector or in parent Injector . >>> from dependencies import Injector , this","title":"this proxy"},{"location":"proxies/this/#simple-links","text":"For example, you can create simple aliases. >>> class Container ( Injector ): ... foo = 1 ... bar = this . foo >>> Container . bar 1 You can use item access on dependencies defined in Injector subclass. >>> class Container ( Injector ): ... foo = { 'a' : 1 } ... bar = this . foo [ 'a' ] >>> Container . bar 1 Tuple, list, set and everything that supports iterable protocol are also supported. You can use this links as usual in the constructor arguments. >>> class Foo : ... def __init__ ( self , bar ): ... self . bar = bar >>> class Container ( Injector ): ... foo = Foo ... bar = this . baz ... baz = 1 >>> Container . foo . bar 1 Also, you can see, that you can define proxy a before the actual dependency it pointing to. You can point a link to the instance method. The actual instance will be built before resolving method access. This is a useful technique to hide whole class with its own state behind a single callable interface. >>> class Foo : ... def method ( self , arg ): ... print ( self ) ... print ( arg ) >>> class Container ( Injector ): ... foo = Foo ... bar = this . foo . method >>> Container . bar ( 1 ) # doctest: +ELLIPSIS <__main__.Foo object at 0x...> 1 You can see that method has access to the Foo instance. So it can call other methods of Foo . You can define dependencies of the Foo class in it constructor as usual.","title":"Simple links"},{"location":"proxies/this/#nested-and-parent-injector-access","text":"Links created with this objects can access attributes defined in the nested injector. >>> class Container ( Injector ): ... foo = this . Bar . baz . __add__ ... class Bar ( Injector ): ... baz = 1 >>> Container . foo ( 2 ) 3 Nested Injector subclasses can access attributes of the parent Injector . Use left shift operator to specify the number of levels to go upper scope. >>> class Container ( Injector ): ... foo = 1 ... class Bar ( Injector ): ... baz = ( this << 1 ) . foo . __add__ >>> Container . Bar . baz ( 2 ) 3","title":"Nested and parent injector access"},{"location":"proxies/this/#full-example","text":"Let's define an application with all settings stored in the dictionary. In production, you can substitute this dictionary with Consul or ZooKeeper client and the rest of the application will be left untouched. >>> class Database : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Cache : ... def __init__ ( self , host , port ): ... self . host = host ... self . port = port >>> class Application : ... def __init__ ( self , db , cache ): ... self . db = db ... self . cache = cache >>> class Container ( Injector ): ... app = Application ... db = this . DB . database ... cache = this . InMemory . cache ... ... class DB ( Injector ): ... database = Database ... host = ( this << 1 ) . settings [ 'database' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'database' ][ 'port' ] ... ... class InMemory ( Injector ): ... cache = Cache ... host = ( this << 1 ) . settings [ 'cache' ][ 'host' ] ... port = ( this << 1 ) . settings [ 'cache' ][ 'port' ] ... ... settings = { ... 'database' : { ... 'host' : 'localhost' , ... 'port' : 5432 , ... }, ... 'cache' : { ... 'host' : 'localhost' , ... 'port' : 6782 , ... }, ... } >>> Container . app # doctest: +ELLIPSIS <__main__.Application object at 0x...> >>> Container . app . db # doctest: +ELLIPSIS <__main__.Database object at 0x...> >>> Container . app . db . port 5432 >>> Container . app . cache # doctest: +ELLIPSIS <__main__.Cache object at 0x...> >>> Container . app . cache . port 6782 \u2014 \u2b50\ufe0f \u2014 The dependencies library is part of the SOLID python family.","title":"Full example"}]}